#separator:tab
#html:false
#guid column:1
#notetype column:2
#deck column:3
#tags column:6
CXyf=jKNW+	Basic-66869	Interview Quesions::React	What are the features of React?	- Uses a virtual DOM instead of manipulating the real DOM directly.\n- Supports server-side rendering (SSR) with hydration.\n- Follows unidirectional data flow.\n- Encourages reusable, composable UI components.	
FoyA}$T9QX	Basic-66869	Interview Quesions::React	What do you know about the Virtual DOM?	- The Virtual DOM (VDOM) is an in-memory representation of the real DOM.\n- It starts as a copy of the real DOM and updates are computed against it.\n\nUpdate steps:\n1) When data changes, React re-renders the UI into the Virtual DOM.\n2) React diffs the previous and current Virtual DOM trees.\n3) React applies minimal changes to the real DOM.	
x7v|@{%0DI	Basic-66869	Interview Quesions::React	Differentiate between Real DOM and Virtual DOM		
cC3W]O5b<X	Basic-66869	Interview Quesions::React	What do you understand from “In React, everything is a component.”	- Components are the building blocks of a React UI.\n- They split the UI into small, independent, reusable pieces.\n- Each component renders independently without affecting other parts of the UI.	
x!BVn-%YPh	Basic-66869	Interview Quesions::React	Explain the purpose of render() in React.	- Class components implement `render()` to return a React element.\n- The returned element describes what should appear in the DOM.	
xP@n:Hci!/	Basic-66869	Interview Quesions::React	How can you embed two or more components into one?	```jsx\nclass MyComponent extends React.Component {\n render() {\n return (\n <div>\n <h1>Hello</h1>\n <Header />\n </div>\n );\n }\n}\n\nclass Header extends React.Component {\n render() {\n return <h1>Header Component</h1>;\n }\n}\n\nReactDOM.render(<MyComponent />, document.getElementById('content'));\n```	
tD#fA>`[%T	Basic-66869	Interview Quesions::React	What are Props?	Props are short hand for Properties in React. They are read-only components which must be kept pure i.e. immutable. They are always passed down from the parent to the child components throughout the application. A child component can never send a prop back to the parent component. This help in maintaining the unidirectional data flow and are generally used to render the dynamically generated data.	
bLvjjlaMiO	Basic-66869	Interview Quesions::React	What is a state in React and how is it used?	- State is a component-owned object that holds information that changes over time.\n- Unlike props, state is private, mutable, and controlled by the component.	
s|1Jjpm@vg	Basic-66869	Interview Quesions::React	What are the different phases of React component’s lifecycle?	- Mounting: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.\n- Updating: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.\n- Unmounting: `componentWillUnmount`.	
j)Q37W1S~;	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillMount()	Executed just before rendering takes place both on the client as well as server-side.	
N>f,)5@dr3	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentDidMount()	Executed on the client side only after the first render.	
ho>RBCRWF0	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillReceiveProps()	Invoked as soon as the props are received from the parent class and before another render is called.	
vh)e2!`1]i	Basic-66869	Interview Quesions::React	Explain the lifecycle method shouldComponentUpdate()	Returns true or false value based on certain conditions. If you want your component to update, return true else return false. By default, it returns true.	
d5&3Sa#z}z	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillUpdate()	Called just before rendering takes place in the DOM.	
NQ2y}4fy!;	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentDidUpdate()	Called immediately after rendering takes place.	
bDPgrPkhAj	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillUnmount()	Called after the component is unmounted from the DOM. It is used to clear up the memory spaces.	
m<ZO3o7eUB	Basic-66869	Interview Quesions::React	What is a synthetic event?	Synthetic events are the objects which act as a cross-browser wrapper around the browser’s native event. They combine the behavior of different browsers into one API. This is done to make sure that the events show consistent properties across different browsers. examples: onClick, onBlur, etc.	
p|p^V2r_Zd	Basic-66869	Interview Quesions::React	What are Higher Order Components(HOC)?	- A HOC is a component that wraps another component to reuse logic.\n- It’s a pattern leveraging React’s compositional nature.\n- HOCs don’t modify the input component’s behavior; they compose it.\n- Benefits include:\n - Code reuse and logic abstraction\n - Render hijacking\n - State abstraction/manipulation\n - Props manipulation	
z)(}a@a$=*	Basic-66869	Interview Quesions::React	In which lifecycle event do you make AJAX requests and why?	- Perform data fetching in `componentDidMount` (or `useEffect` in function components).\n- Ensures the component is mounted before calling `setState`.\n- Avoids updates on unmounted components.	
uJ}BIoh[@B	Basic-66869	Interview Quesions::React	How do you tell React to build in Production mode and what will that do?	- Configure your bundler to set `process.env.NODE_ENV = 'production'`.\n- Enables production optimizations and removes development warnings.\n- Minify code to leverage dead-code elimination and reduce bundle size.	
xq?sv-se$N	Basic-66869	Interview Quesions::React	What is JSX (JS XML)?	- JSX is syntax sugar for `React.createElement()`.\n- It lets you write component templates in HTML-like syntax that compile to JavaScript.	
OL!DT=<3S=	Basic-66869	Interview Quesions::React	What is React?	React is an open-source front-end JavaScript library that is used for building user interfaces, especially for single-page applications. It is used for handling view layer for web and mobile apps.	
L$ga}WG3v[	Basic-66869	Interview Quesions::React	What is the difference between state and props?	- Props are inputs passed to a component (like function parameters).\n- State is managed within the component (like local variables) and can change over time.	
Ik1K8!QFj`	Basic-66869	Interview Quesions::React	"What is ""key"" prop?"	- `key` is a special string attribute used in lists to help React identify items.\n- Improves diffing by tracking inserted, removed, or changed elements.	
s09rc`.>(;	Basic-66869	Interview Quesions::React	What is context?	- Context lets you pass data through the component tree without prop drilling.	
Ll)X1;&(:*	Basic-66869	Interview Quesions::React	What is reconciliation?	- When props/state change, React compares the new element with the previous.\n- If different, React updates the DOM minimally — this is reconciliation.	
Ix{-[~VBNX	Basic-66869	Interview Quesions::React	What are fragments?	- Fragments let components return multiple children without extra DOM nodes.\n- Use `<>...</>` or `<React.Fragment>...</React.Fragment>`.	
jrI~R6S+um	Basic-66869	Interview Quesions::React	What are error boundaries in React v16?	- Error boundaries catch errors in child components and render fallback UI.\n- Implement with `componentDidCatch(error, info)` and/or `static getDerivedStateFromError()`.	
NS#J5g]Rh2	Basic-66869	Interview Quesions::React	What is the use of react-dom package?	- Provides DOM-specific methods for React apps:\n - `render(element, container)`\n - `hydrate(element, container)` (for SSR hydration)\n - `unmountComponentAtNode(container)`\n - `findDOMNode(instance)` (prefer refs instead)\n - `createPortal(child, container)`	
fI:#fODmB`	Basic-66869	Interview Quesions::React	What is ReactDOMServer?	- Enables rendering components to static markup for SSR.\n- Common methods:\n - `renderToString(component)`\n - `renderToStaticMarkup(component)`\n\nExample:\n\n```js\nimport ReactDOMServer from 'react-dom/server';\n\nconst html = ReactDOMServer.renderToString(<App />);\n// send html as response\n```	
QnC1mCl>/.	Basic-66869	Interview Quesions::React	Why is a component constructor called only once?	React's reconciliation algorithm assumes that if a custom component appears in the same place on subsequent renders, it's the same component as before, so reuses the previous instance rather than creating a new one.	
x4PNquO)-1	Basic-66869	Interview Quesions::React	What are the common folder structures for React?	- Grouping by feature or route (co-locate components, hooks, tests).\n- Grouping by file type (components, hooks, styles, tests in separate dirs).	
IEl=a.8`Zy	Basic-66869	Interview Quesions::React	What is the benefit of styles modules?	It is recommended to avoid hard coding style values in components. Any values that are likely to be used across different UI components should be extracted into their own modules.	
yX93pYzyV(	Basic-66869	Interview Quesions::React	What is React Router?	- A routing library that keeps the UI in sync with the URL.\n- Hooks: `useNavigate` (v6), `useLocation`, `useParams`.\n- Covers:\n - Configuring routes\n - Navigating with `Link`\n - Nested routes/layouts\n - Programmatic navigation\n - URL params and search params	
BHB7^Vf4qD	Basic-66869	Interview Quesions::React	How React Router is different from history library?	- React Router wraps the `history` library, managing browser and hash histories.\n- Adds declarative routing components and React integration.\n- Provides memory history for non-browser environments (React Native, tests).	
HZ`|B1)+3~	Basic-66869	Interview Quesions::React	What is React Interalization?	is part of FormatJS which provides bindings to React. It helps to format strings, dates, numbers, or pluralization	
JTC4IS2r3U	Basic-66869	Interview Quesions::React	What is Flux?	- Flux is an architectural pattern favoring unidirectional data flow over MVC.\n- Complements React; used internally at Facebook.	
D%yTdeOz31	Basic-66869	Interview Quesions::React	What is Redux?	- Redux is a predictable state container inspired by Flux.\n- Works with React or other view libraries.\n- Hooks: `useSelector`, `useDispatch`.	
L?3|K^p;nZ	Basic-66869	Interview Quesions::React	What are the core principles of Redux?	- Single source of truth: entire app state in one store.\n- State is read-only: only actions describe state changes.\n- Changes via pure functions: reducers transform state based on actions.	
nT}{UKCH@y	Basic-66869	Interview Quesions::React	What is the difference between mapStateToProps() and mapDispatchToProps()?	mapStateToProps() is a utility which helps your component get updated state (which is updated by some other components) mapDispatchToProps() is a utility which will help your component to fire an action event (dispatching action which may cause change of application state)	
cW0lc`wjNe	Basic-66869	Interview Quesions::React	Can I dispatch an action in reducer?	Your reducer should simply digest the action payload and returning a new state object. Adding listeners and dispatching actions within the reducer can lead to chained actions and other side effects.	
O|C$F95Ya-	Basic-66869	Interview Quesions::React	What is the difference between React context and React Redux?	Context is built in tool with React and required minimal setup, whereas Redux requires additional installation and extensive setup to integrate it with a React Application. Context is specifically designed for static data, that is not often refreshed or updated, whereas Redux is better in the high-frequency update data field. Context used for UI logic and State Management Logic are in the same component, whereas Redux has better code organization with separate UI logic and State Management Logic Redux ease to debug with Redux Dev Tool	
cO*hTP`t{X	Basic-66869	Interview Quesions::React	How to make AJAX request in Redux?	You can use redux-thunk middleware which allows you to define async actions.	
h[:7?W`BQ;	Basic-66869	Interview Quesions::React	What is the difference between component and container in React Redux?	Component is a class or function component that describes the presentational part of your application. Container is an informal term for a component that is connected to a Redux store. Containers subscribe to Redux state updates and dispatch actions, and they usually don't render DOM elements; they delegate rendering to presentational child components.	
yhp:KT%)!|	Basic-66869	Interview Quesions::React	What is redux-saga and its benifits?	redux-saga is a library that aims to make side effects (asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better. Benifits: - make asynchronous flows easy to read, write, and test - enable numerous approaches to tackling parallel execution, task concurrency, task racing, task cancellation, and more	
ltnzbOZ4mz	Basic-66869	Interview Quesions::React	What are the differences between call() and put() in redux-saga?	Both call() and put() are effect creator functions. call() function is used to create effect description, which instructs middleware to call the promise. put() function creates an effect, which instructs middleware to dispatch an action to the store.	
E))z6dtXj3	Basic-66869	Interview Quesions::React	What is Redux Thunk?	Redux Thunk middleware allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods dispatch() and getState() as parameters.	
h3pZ0Tf[Zs	Basic-66869	Interview Quesions::React	What are the differences between redux-saga and redux-thunk?	Both Redux Thunk and Redux Saga take care of dealing with side effects. In most of the scenarios, Thunk uses Promises to deal with them, whereas Saga uses Generators. Thunk is simple to use and Promises are familiar to many developers, Sagas/Generators are more powerful but you will need to learn them. But both middleware can coexist, so you can start with Thunks and introduce Sagas when/if you need them.	
D&@%=.daPO	Basic-66869	Interview Quesions::React	What are Redux selectors and why to use them?	- Selectors take state and return derived data for components.\n- Benefits:\n - Compute derived data to keep state minimal.\n - Memoize to avoid recomputation unless inputs change.	
lQR+]!`<bS	Basic-66869	Interview Quesions::React	What is an action in Redux?	Actions are plain JavaScript objects or payloads of information that send data from your application to your store. Actions must have a type property that indicates the type of action being performed.	
K>1*eOxf5&	Basic-66869	Interview Quesions::React	What is reselect and how it works?	Reselect is a selector library (for Redux) which uses same concept with Redux Selector. It was originally written to compute derived data from Redux-like applications state, and not recomputed unless one of it arguments changed. It supports to create a new selector which receive other selectors as argument.	
kI2bdErp*~	Basic-66869	Interview Quesions::React	What are Styled Components?	- `styled-components` lets you style components using CSS-in-JS.\n- Co-locates styles with components and removes CSS-to-component mapping.	
s<_LqmJ_tz	Basic-66869	Interview Quesions::React	Do I need to keep all my state into Redux? Should I ever use react internal state?	It is up to the developer's decision. There are the some rules to determine what kind of data should be put into Redux Is the same data existed in store?Do other parts of the application care about this data?Do you need to be able to create further derived data based on this original data?	
tZuNHD4?q@	Basic-66869	Interview Quesions::React	What is the purpose of registerServiceWorker in React?	React creates a service worker for you without any configuration by default. The service worker is a web API that helps you cache your assets and other files so that when the user is offline or on a slow network, he/she can still see results on the screen, as such, it helps you build a better user experience. It's all about adding offline capabilities to your site.	
C&Ugl6PT|A	Basic-66869	Interview Quesions::React	What is React memo function?	Class components can be restricted from re-rendering when their input props are the same using PureComponent or shouldComponentUpdate. Now you can do the same with function components by wrapping them in React.memo.	
sdfVTRnIMW	Basic-66869	Interview Quesions::React	What is React lazy function?	The React.lazy function lets you render a dynamic import as a regular component. It will automatically load the seperated bundle containing the imported component when the component gets rendered. The module must be a default export containing a React component.	
Qv$v0hsu4H	Basic-66869	Interview Quesions::React	What are hooks? What rules need to be followed for hooks?	Hooks is a new feature(React 16.8) that lets you use state and other React features without writing a class. You need to follow two rules in order to use hooks,Call Hooks only at the top level of your react functions. i.e, You shouldn’t call Hooks inside loops, conditions, or nested functions.Call Hooks from React Functions or another hooks only.The naming convention of hooks should start with the prefix use	
d9>c:-w]`Y	Basic-66869	Interview Quesions::React	In which scenarios error boundaries do not catch errors?	Below are the cases in which error boundaries doesn't work:Inside Event handlers Asynchronous code using setTimeout or requestAnimationFrame callbacks During Server side rendering When errors thrown in the error boundary code itself	
kN0oYYZvfJ	Basic-66869	Interview Quesions::React	What is the proper placement for error boundaries?	- You can wrap top-level route components to display a generic error message for the entire application. - You can also wrap individual components in an error boundary to protect them from crashing the rest of the application and create the error state for each of components independently	
9E/elaX9]	Basic-66869	Interview Quesions::React	What is the methods order when component re-rendered?	An update can be caused by changes to props or state. The below methods are called in the following order when a component is being re-rendered.static getDerivedStateFromProps()shouldComponentUpdate()render()getSnapshotBeforeUpdate()componentDidUpdate()	
Mm_cR69)FD	Basic-66869	Interview Quesions::React	What are the methods invoked during error handling?	Below methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.static getDerivedStateFromError()componentDidCatch()	
Hep+>5!.c>	Basic-66869	Interview Quesions::React	What is the purpose of unmountComponentAtNode method?	This method is available from react-dom package and it removes a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns true if a component was unmounted and false if there was no component to unmount.	
NGBh@8n]?	Basic-66869	Interview Quesions::React	What is NextJS and major features of it?	Next.js is a popular and lightweight framework for static and server‑rendered applications built with React. It also provides styling and routing solutions. Below are the major features provided by NextJS,Server-rendered by defaultAutomatic code splitting for faster page loadsSimple client-side routing (page based)Webpack-based dev environment which supports (HMR)Able to implement with Express or any other Node.js HTTP serverCustomizable with your own Babel and Webpack configurations	
gA2?HOKfQ$	Basic-66869	Interview Quesions::React	Optimizing performance in a React application? List the React hook functions	Keeping component state local where necessary. (useState, useEffect)Split component to small ones if it becomes more complex.Avoid pass props down in many levels (State management: React-redux, useContext, useReducer)Memoizing React components to prevent unnecessary re-renders. (React.memo)Memoizing expensive React states or methods to reduce recomputation. (useMemo, useCallback)Building a custom hook to extract a logic into a reusable function Use refs to store mutable values without re-rendering the entire component.use debounce & throttle to avoid send multiple requests in a short time. Code-splitting in React using dynamic import()Windowing or list virtualizationLazy loading images	
QGo2Qir#W_	Basic-66869	Interview Quesions::React	React vs Angular	React is a library, but Angular is a Full-featured Framework. The virtual DOM and one-way data binding are used by React.js, but the real DOM and two-way data binding are used by Angular.	
ENY(b|8)-X	Basic-66869	Interview Quesions::React	How to write unit tests for custom hooks?	We would use react-hooks-testing-library write the unit test. There are two methods we need to know: renderHook: The renderHook can render custom hook, you can operations the custom hook like in the component.act: The act can execute the methods return from custom hook that makes sure all updates have been processed Reference: React | Write a unit test for custom hooks in ten minutes - DEV Community	
Mh[jf[d7|q	Basic-66869	Interview Quesions::React	What is React Testing Library?	React Testing Library is a set of helpers builds on top of DOM Testing Library that let you test React components. This allows you to get your tests closer to using your components the way a user will It's supported by CRA as default. Sample test steps: - Arrange (render): The method renders a React element into the DOM. - Act (fireEvent): The method allows you to fire events to simulate user actions. - Assert: assert that the test case is correct	
h!$Xko2UDE	Basic-66869	Interview Quesions::React	Testing Recipes in React components	Setup/Teardown (Arrange): setup a DOM element as a render target (beforeEach) or “clean up” and unmount the tree on exiting (afterEach) act / assert: makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions Rendering: test whether a component renders correctly for given props. Data Fetching: mock requests with dummy data Mocking Modules: Mocking out modules (ex: 3rd libraries) with dummy replacements Events: dispatching real DOM events on DOM elements Timers: You can use fake timers only in some tests Snapshot Testing: you save “snapshots” of the rendered component output ensure that a change is correct	
LY)5dv7=b:	Basic-66869	Interview Quesions::React	What are end-to-end tests?	End-to-end tests are useful for testing longer workflows, especially when they’re critical to your business (such as payments or signups). For these tests, you’d probably want to test how a real browser renders the whole app, fetches data from the real API endpoints, uses sessions and cookies, navigates between different links. We can assert on side effects not just in the browser, but potentially on the backend as well.	
Gyhl*=HSc`	Basic-66869	Interview Quesions::React	Recoil State management core concepts	Recoil is a state management library for React. Recoil lets you create a data-flow graph that flows from atoms (shared state) through selectors (pure functions) and down into your React components. Atoms are units of state that components can subscribe to. When an atom is updated, each subscribed component is re-rendered with the new value. Atoms can be used in place of React local component state. If the same atom is used from multiple components, all those components share their state. Selectors is a pure function that accepts atoms or other selectors as input. When these upstream atoms or selectors are updated, the selector function will be re-evaluated. Components can subscribe to selectors just like atoms, and will then be re-rendered when the selectors change. Popular components: - RecoilRoot​: Components that use recoil state need RecoilRoot to appear somewhere in the parent tree. A good place to put this is in your root component - Atom​: An atom represents a piece of state. Atoms can be read from and written to from any component. Components that read the value of an atom are implicitly subscribed to that atom, so any atom updates will result in a re-render of all components subscribed to that atom - Selector​: A selector represents a piece of derived state. Derived state is a transformation of state. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way - Components that need to read from and write to an atom should use useRecoilState() - We can use the useRecoilValue() hook to read the value of selector Getting Started | Recoil (recoiljs.org)	
c,l~8(c`.7	Basic-66869	Interview Quesions::React	Client Site Rendering (CSR), Server Site Rendering (SSR) and SSG (Static Site Generation)	- CSR: Server sending HTML and JS files -> Browser downloads JS -> Browser executes React -> Page full dynamic (loaded) - SSR: Server built out HTML page and sends to the browser -> Static HTML is rendered and Browser downloads JS in background (loaded) -> Loaded React adds interactivity to the page -> Page full dynamic - SSG: HTML files are generated on build time -> Static HTML is rendered and Browser downloads JS in background-> Loaded React adds interactivity to the page -> Page full dynamic Usage: - CSR: Login page, dashboard page, ... and the pages don't need SEO - SSR: page with dynamic data but still have SEO and expect super fast initial loading - SSG: for pages which don't need to be updated frequently and expect super fast initial loading	
ukjH*S<[!,	Basic-66869	Interview Quesions::React	How to Create a React Component Library	InitCreating ComponentsAdding TypescriptAdding RollupBuilding Your LibraryMore advances: Adding CSSOptimizingAdding TestsAdding StorybookAdding SCSS	
O^J|aZOs#P	Basic-66869	Interview Quesions::React	When should you memoize in React?	When should you memoize in React (prateeksurana.me)	
gEdvk}bCx<	Basic-66869	Interview Quesions::React	What is React Fiber?	Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM. Fiber improves the Virtual DOM and comparation steps of reconcilation algo	
q(a+%30cl2	Basic-66869	Interview Quesions::React	useState hook	- Returns a stateful value, and a function to update it. - During the initial render, the returned state (state) is the same as the value passed as the first argument (initialState). - Lazy initial state: The initialState argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render - The setState function is used to update the state. It accepts a new state value and enqueues a re-render of the component. - If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value. - During subsequent re-renders, the first value returned by useState will always be the most recent state after applying updates. - React guarantees that setState function identity is stable and won’t change on re-renders. This is why it’s safe to omit from the useEffect or useCallback dependency list. - Bailing out of a state update: If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects (React uses the Object.is comparison algorithm.) - Batching of state updates: React may group several state updates into a single re-render to improve performance.	
o[>+!Bp3;=	Basic-66869	Interview Quesions::React	useRef	useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component. The only difference between useRef() and creating a {current: ...} object yourself is that useRef will give you the same ref object on every render. Keep in mind that useRef doesn’t notify you when its content changes. Mutating the .current property doesn’t cause a re-render	
Nz8&|&mPsU	Basic-66869	Interview Quesions::React	React Profiler API	The Profiler measures how often a React application renders and what the “cost” of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from optimizations such as memoization.	
kd9Bf6FSN3	Basic-66869	Interview Quesions::React	When exactly does React clean up an effect?	React performs the cleanup when the component unmounts. However, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time.	
A<}Q3=<z&e	Basic-66869	Interview Quesions::React	useEffect	- By default, effects run after every completed render - Allow us Cleaning up an effect before the component is removed from the UI - if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect - Timing: useEffect is deferred until after the browser has painted (rendered) - Conditionally firing an effect + only be recreated when deps changes + If you pass an empty deps array, only be created after the intial rendered Practice challenge: https://www.greatfrontend.com/questions/javascript/use-query?framework=react&tab=coding https://react.dev/learn/synchronizing-with-effects	
0nio)!l~N	Basic-66869	Interview Quesions::React	useEffect vs useLayoutEffect	useEffect runs asynchronously after the browser paints, making it ideal for side effects that don't affect layout. useLayoutEffect runs synchronously before painting, perfect for DOM measurements or preventing visual flicker, but should be used sparingly as it blocks the browser's painting process	
J0~8W6;Q*@	Basic-66869	Interview Quesions::React	NextJS + Astro	NextJS to Astro: more control = faster sites - YouTube	
PHP~2a$F~o	Basic-66869	Interview Quesions::React	useEffect called twice in react 18	amazing features that Identifying unsafe lifecycles => we shouldn't disable it	
Tm9i!mbr$?	Basic-66869	Interview Quesions::JavaScript	What is the Document Object Model (DOM)?	The Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects, where each object corresponds to a part of the document (e.g., elements, attributes, text). The DOM allows developers to access and manipulate the content, structure, and style of a web page using JavaScript.	
=C10XTq[%+	Basic-66869	Interview Quesions::JavaScript	How do you add an event listener to an element?	To add an event listener on an element, first get that element through one of the `document` methods (e.g. `getElementById`).\nThen use the element’s `addEventListener` method.\n\nThe method receives the event name (e.g. `click`, `keyup`, `mouseup`), the event handler function, and optionally options such as `capture`.\n\n```js\nconst button = document.getElementById('submit');\nfunction handleClick(e) { console.log('Clicked!', e.target); }\nbutton.addEventListener('click', handleClick, { capture: false });\n```	
1VAu-op2HU	Basic-66869	Interview Quesions::JavaScript	What is the difference between null and undefined?	In JavaScript, “undefined” is the default value new variables take, and it means the variable has been defined but it hasn’t been assigned any value just yet.\n\nAnd “null” is actually a value that signals “no value” or “no object”, it is specifically assigned to the variable by the developer.	
d>3F?Xx3:1	Basic-66869	Interview Quesions::JavaScript	What is the difference between cookies, sessionStorage, and localStorage?	Cookies are small pieces of data that are stored on the client-side (i.e. in the user's browser). They are sent back to the server with every HTTP request, which allows servers to identify and remember information about the user. Cookies are commonly used for things like session management, user authentication, and personalization.\n\nSessionStorage and localStorage are two mechanisms for storing data on the client-side, but they differ in how they persist data. sessionStorage stores data for the duration of the page session, which means that the data is lost when the user closes the browser tab or window. localStorage, on the other hand, stores data indefinitely, even after the browser is closed.\n\nUse case:\n\n- Cookies: Used for session management, user authentication, and personalization.\n- sessionStorage: Used for storing temporary data that should be available for the duration of the page session.\n- localStorage: Used for storing data that should persist even after the browser is closed.	
5Bv7_9IB[3	Basic-66869	Interview Quesions::JavaScript	How does the browser render a website?		
M^wUK1Tr?l	Basic-66869	Interview Quesions::JavaScript	What are closures, and how/why would you use them?	A closure is a function that has access to the variables in its outer scope, even after the outer function has returned. In other words, a closure allows a function to “remember” the environment in which it was created.\n\nClosures are commonly used in JavaScript for things like creating private variables and functions, implementing currying, and avoiding memory leaks.	
xIt4%CGGz8	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain why the following doesn't work as an IIFE: function foo(){ }();. What needs to be changed to properly make it an IIFE?	IIFE (Immediately Invoked Function Expression)\n\nDefinition\n\n- An IIFE is a function expression that runs immediately after it is created. It creates a private scope and avoids polluting the global scope.\n\nWhy `function foo(){}();` throws\n\n- `function foo(){}` is parsed as a function declaration.\n- The trailing `();` tries to call a function but there is no expression to call, resulting in `Uncaught SyntaxError: Unexpected token )`.\n\nCorrect syntax\n\n```js\n(function foo() {\n // code\n})();\n// or\n(function foo() {\n // code\n})();\n// or using arrow functions\n(() => {\n // code\n})();\n```\n\nWhy parentheses matter\n\n- Wrapping the function in `()` turns the declaration into a function expression, which can then be immediately invoked with the trailing `()`.\n- The function does not leak into the global scope; you may omit the name unless self-reference is needed.\n\nUsing `void` (and its caveat)\n\n```js\nconst result = void (function bar() {\n return 'foo';\n})();\nconsole.log(result); // undefined\n```\n\n- `void` forces the expression to evaluate to `undefined`, so you cannot use the function’s return value. Prefer the parentheses form if you need the returned value.\n\nTypical use cases\n\n- Create a one-off initialization.\n- Encapsulate variables and avoid globals.\n- Implement module patterns or set up event listeners with private state.	
lSIl-tvZ<*	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain how **this** works in JavaScript	The value of `this` depends on how the function is called.\n\nRules:\n- Called with `new`: `this` is a brand new object.\n- Called via `apply`, `call`, or `bind`: `this` is the object passed as the first argument.\n- Called as a method (e.g., `obj.method()`): `this` is the object owning the method.\n- Called as a plain function: `this` is the global object (`window` in browsers). In strict mode, `this` is `undefined`.\n- If multiple rules apply, precedence determines `this`.\n- Arrow functions ignore all above and capture `this` from the enclosing lexical scope at creation.\n\nES6 changes:\n- Arrow functions use enclosing lexical `this`. This is convenient but prevents callers from controlling context via `.call` or `.apply`.\n- Be mindful when refactoring legacy code relying on dynamic `this` binding.\n\nReferences:\n- https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3\n- https://stackoverflow.com/a/3127440/1751946	
sSRksn3Lj>	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain how prototypal inheritance works	All JavaScript objects have a `prototype` property that references another object.\nWhen a property is accessed on an object and is not found, the engine looks up the prototype chain until it finds the property or reaches the end.\nThis behavior simulates classical inheritance but is more accurately delegation.\n\nExample: polyfill for `Object.create`\n```js\nif (typeof Object.create !== 'function') {\n Object.create = function (parent) {\n function Tmp() {}\n Tmp.prototype = parent;\n return new Tmp();\n };\n}\n```\n\nExample: inheritance via prototypes\n```js\nfunction Parent() { this.name = 'Parent'; }\nParent.prototype.greet = function () { console.log('hello from Parent'); };\n\nconst child = Object.create(Parent.prototype);\nchild.cry = function () { console.log('waaaaaahhhh!'); };\n\nchild.cry(); // waaaaaahhhh!\nchild.greet(); // hello from Parent\n```\n\nNotes:\n- `.greet` is not defined on `child`, so the engine goes up the prototype chain and finds it on `Parent.prototype`.\n- Use `Object.create(Parent.prototype)` for prototype methods to be inherited.\n- `child.constructor` points to `Parent` by default.\n\nCorrecting `constructor` with a subtype\n```js\nfunction Child() { Parent.call(this); this.name = 'child'; }\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n\nconst c = new Child();\nc.cry = function () { console.log('waaaaaahhhh!'); };\nc.cry(); // waaaaaahhhh!\nc.greet(); // hello from Parent\nconsole.log(c.constructor.name); // 'Child'\n```\n\nReferences:\n- https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson\n- https://davidwalsh.name/javascript-objects\n- https://crockford.com/javascript/prototypal.html\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain	
uxIl-AwVOe	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between a variable that is: null, undefined or undeclared? How would you go about checking for any of these states?	Undeclared\n- Created when assigning to an identifier not previously declared with `var`, `let`, or `const`.\n- Defined globally (outside current scope). In strict mode, a `ReferenceError` is thrown on assignment.\n- Avoid at all costs. To detect, wrap usage in `try/catch`.\n```js\nfunction foo() { x = 1; } // ReferenceError in strict mode\ntry { foo(); } catch (e) { console.error(e); }\n```\n\nUndefined\n- Declared but not assigned a value; type is `undefined`.\n- Functions without a return value evaluate to `undefined`.\n- Check using strict equality or `typeof`. Do not use `==` which also matches `null`.\n```js\nvar foo;\nconsole.log(foo); // undefined\nconsole.log(foo === undefined); // true\nconsole.log(typeof foo === 'undefined'); // true\nconsole.log(foo == null); // true (wrong check)\n\nfunction bar() {}\nvar baz = bar();\nconsole.log(baz); // undefined\n```\n\nNull\n- Explicitly assigned `null` represents no value; different from `undefined`.\n- Check using strict equality; avoid `==` which matches `undefined`.\n```js\nvar foo = null;\nconsole.log(foo === null); // true\nconsole.log(typeof foo === 'object'); // true\nconsole.log(foo == undefined); // true (wrong check)\n```\n\nPersonal habit: explicitly assign `null` if a variable is declared but not yet used.\nLinters will help catch references to undeclared variables.\n\nReferences:\n- https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables\n- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined	
B#B(?XiGcl	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is a closure, and how/why would you use one?	A closure gives you access to an outer function's scope from an inner function.\nIt combines a function and the lexical environment in which it was declared.\n\nClosure scope chains:\n1. Own scope (variables defined within the function).\n2. Outer function variables.\n3. Global variables.\n\nWhy use closures?\n- Data privacy / emulate private methods (module pattern).\n- Partial application or currying.\n\nReference: Closures - JavaScript | MDN (mozilla.org).	
L3n$_#_Xnp	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Can you describe the main difference between a .forEach loop and a .map() loop and why you would pick one versus the other?	To understand the differences, consider what each function does.\n\n`.forEach`\n- Iterates through array elements.\n- Executes a callback for each element.\n- Does not return a value.\n```js\nconst a = [1, 2, 3];\nconst doubled = a.forEach((num, index) => {\n // Do something with num and/or index\n});\nconsole.log(doubled); // undefined\n```\n\n`.map`\n- Iterates through array elements.\n- Maps each element to a new element by calling a function on each element, creating a new array.\n```js\nconst a = [1, 2, 3];\nconst doubled = a.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6]\n```\n\nMain difference:\n- `.map()` returns a new array. If you need the result and do not wish to mutate the original array, `.map()` is the clear choice.\n- If you simply need to iterate over an array, `.forEach` is fine.	
j&fIguVlLP	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between host objects and native objects?	Native objects are part of the JavaScript language defined by the ECMAScript specification (e.g., `String`, `Math`, `RegExp`, `Object`, `Function`).\nHost objects are provided by the runtime environment (browser or Node), such as `window`, `XMLHttpRequest`, etc.	
u$0(Ek&Zf2	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between .bind, .call and .apply?	`call` and `apply` invoke a function immediately and set `this`.\n- `call(thisArg, a, b)` — comma-separated arguments.\n- `apply(thisArg, [a, b])` — arguments as an array.\n`bind` returns a new function with `this` (and optionally leading args) fixed.\n```js\nfunction add(a, b) { return a + b; }\nconsole.log(add.call(null, 1, 2)); // 3\nconsole.log(add.apply(null, [1, 2])); // 3\n\nfunction Temp() { this.c = 1; }\nTemp.prototype.add = function (a, b) { return (this.c || 0) + a + b; };\n\nconst temp = new Temp();\nconsole.log(temp.add(1, 2)); // 4\nconsole.log(temp.add.call({ c: 2 }, 1, 2)); // 5\nconsole.log(temp.add.apply({ c: 3 }, [1, 2])); // 6\n\nconst bound = temp.add.bind({ c: 4 });\nconsole.log(bound(1, 2)); // 7\n```	
d=D4Joc)~F	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain Function.prototype.bind.	Definition\n- `bind(thisArg, ...args)` returns a new function with `this` fixed to `thisArg` and optionally prepends `args`.\n\nWhy use it\n- Preserve method `this` when passing as a callback.\n- Partially apply leading arguments.\n\nExample\n```js\nconst module = {\n x: 42,\n getX() { return this.x; }\n};\n\nconst unbound = module.getX;\nconsole.log(unbound()); // undefined in strict mode\n\nconst bound = module.getX.bind(module);\nconsole.log(bound()); // 42\n\nfunction add(a, b, c) { return a + b + c; }\nconst add5 = add.bind(null, 5);\nconsole.log(add5(1, 2)); // 8\n```	
P_L+L6Fx^f	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Have you ever used JavaScript templating? If so, what libraries have you used?	Libraries used\n- Handlebars, Underscore/Lodash templates, AngularJS, JSX.\n\nNotes\n- JSX is concise and type-friendly; AngularJS string-heavy templates are prone to typos.\n- ES2015 template literals work for simple templates but do not escape by default.\n\nExample\n```js\nconst name = 'Ada';\nconst template = `<div>My name is: ${name}</div>`;\n// Beware: interpolation is not escaped — sanitize user input to prevent XSS.\n```	
NO?|xWO8/f	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	"Explain ""hoisting""."	Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation.\n\nExample\n```js\n// Function declarations are hoisted\nhoisted(); // works\nfunction hoisted() {}\n\n// var is hoisted (initialized to undefined)\nconsole.log(a); // undefined\nvar a = 1;\n\n// let/const are in the Temporal Dead Zone\n// console.log(b); // ReferenceError\nlet b = 2;\n```	
OvAxocDxWd	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Describe event bubbling.	When an event triggers on a DOM element, it is handled on that element and then bubbles up through ancestors to the document. Bubbling enables event delegation.\n```html\n<ul id="list">\n <li>Item</li>\n</ul>\n<script>\ndocument.getElementById('list').addEventListener('click', (e) => {\n // Delegate: handle clicks on child <li> elements\n if (e.target.tagName === 'LI') {\n console.log('Clicked:', e.target.textContent);\n }\n});\n</script>\n```	
t#z{vItZ[o	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	"What's the difference between an ""attribute"" and a ""property""?"	Attributes are defined in HTML markup; properties are defined on the DOM node.\nExample:\n```html\n<input type="text" value="Hello">\n```\n```js\nconst input = document.querySelector('input');\nconsole.log(input.getAttribute('value')); // Hello\nconsole.log(input.value); // Hello\n\n// After changing the field value to "World!"\nconsole.log(input.getAttribute('value')); // Hello\nconsole.log(input.value); // Hello World!\n```	
GPr)]um6Aa	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is the difference between == and ===?	`==` is the abstract equality operator; `===` is the strict equality operator.\n`==` compares after type conversion; `===` does not convert types.\n\nExamples of `==` pitfalls:\n```js\n1 == '1'; // true\n1 == [1]; // true\n1 == true; // true\n0 == ''; // true\n0 == '0'; // true\n0 == false; // true\n```\n\nAdvice: avoid `==` except when comparing against `null` or `undefined` for convenience.\n```js\nvar a = null;\nconsole.log(a == null); // true\nconsole.log(a == undefined); // true\n```	
Di;q&0JI2e	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?	Every script has access to the global scope, and if everyone uses the global scope to define their variables, collisions will likely occur	
QR/fx-@j4R	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain what a single page app is and how to make one SEO-friendly.	Definition\n- A Single Page Application (SPA) uses client-side rendering; navigation updates the URL without full page reloads.\n\nBenefits\n- Responsive navigation without flash between pages.\n- Fewer repeated asset downloads; clearer client/server separation.\n\nDownsides\n- Heavier initial load.\n- Requires server routing to a single entry point.\n- Content relies on JS execution, which can hurt SEO if crawlers don’t run JS.\n\nSEO-friendly approaches\n- Server-Side Rendering (SSR) or Static Site Generation (SSG).\n- Pre-rendering services (e.g., Prerender.io) to serve HTML to crawlers.\n- Ensure metadata: dynamic `<title>`, `<meta>` tags, canonical links.\n- Generate sitemap and use structured data where appropriate.	
Gro(j1-0.P	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What are the pros and cons of using Promises instead of callbacks?	Pros\n- Avoids callback hell; supports readable chaining via `.then()`.\n- Easy parallelism with `Promise.all`.\n- Safer semantics: avoids early/late/multiple callback invocation and error swallowing.\n\nCons\n- Slightly more complex semantics for beginners.\n- Requires polyfills in older environments.	
f4B<J6Zi=J	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is Promises?	Definition\n- A Promise represents a future value: `pending` → `fulfilled` or `rejected`.\n- `then`/`catch` return new promises, enabling chaining.\n\nExample\n```js\nconst fetchData = () => new Promise((resolve, reject) => {\n setTimeout(() => resolve('data'), 100);\n});\n\nfetchData()\n .then(v => v.toUpperCase())\n .catch(err => console.error(err));\n```	
xOaFh|/qlF	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What tools and techniques do you use for debugging JavaScript code?	Tools\n- Chrome DevTools (sources, network, performance)\n- React DevTools, Redux DevTools; Vue DevTools\n\nTechniques\n- `debugger` statements to pause execution.\n- Structured `console.*` logging; log levels and grouping.\n- Narrow repro cases; isolate async flows and side effects.	
h[x>(Ez0c~	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain the difference between mutable and immutable objects.	Definitions\n- Mutable: state can change after creation.\n- Immutable: state cannot change after creation.\n\nBuilt-in\n- Primitives like numbers and strings are immutable; regular objects are mutable.\n\nApproaches\n```js\n// Constant property\nconst myObject = {};\nObject.defineProperty(myObject, 'number', {\n value: 42,\n writable: false,\n configurable: false,\n});\n\n// Prevent extensions\nconst obj = { a: 2 };\nObject.preventExtensions(obj);\nobj.b = 3; // ignored or TypeError in strict mode\n\n// Seal\nconst sealed = Object.seal({ a: 1 }); // no adding/removing, can change values\n\n// Freeze\nconst frozen = Object.freeze({ a: 1 }); // no adding/removing/changing\n```	
nVy)4CLX9l	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain the difference between synchronous and asynchronous functions.	Synchronous\n- Blocks until work completes; code runs in order.\n\nAsynchronous\n- Returns immediately; completion handled via callbacks/promises/async-await.\n- Keeps UI responsive in browsers.\n\nExample\n```js\nconsole.log('A');\nsetTimeout(() => console.log('B'), 0);\nconsole.log('C');\n// Output: A, C, B\n```	
P-jr#X^8>.	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is event loop? What is the difference between call stack and task queue?	Event loop\n- Monitors the call stack; when empty, dequeues tasks from queues to execute.\n\nQueues\n- Macro-task queue: `setTimeout`, I/O callbacks.\n- Micro-task queue: promises (`then`/`catch`), `queueMicrotask` — runs before macro-tasks between ticks.\n\nExample\n```js\nconsole.log('start');\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('microtask'));\nconsole.log('end');\n// start, end, microtask, timeout\n```	
pTgUpHtFDS	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What are the differences between variables created using let, var or const?	Scope\n- `var`: function-scoped.\n- `let`/`const`: block-scoped.\n```js\nfunction foo() {\n var a = 1; let b = 2; const c = 3;\n}\n// a,b,c not accessible outside\n```\n\nHoisting\n- `var` is hoisted and initialized to `undefined`.\n- `let`/`const` are hoisted but in Temporal Dead Zone until declared.\n```js\nconsole.log(v); // undefined\nvar v = 'v';\n// console.log(l); // ReferenceError\nlet l = 'l';\n```\n\nRedeclaration & reassignment\n- `var` allows redeclaration; `let`/`const` do not.\n- `let` allows reassignment; `const` does not.\n```js\nvar x = 'x'; var x = 'x2'; // ok\nlet y = 'y'; // let y = 'y2'; // SyntaxError\nconst z = 'z'; // z = 'z2'; // TypeError\n```	
l`fNWr-H@K	Basic-66869	Interview Quesions::JavaScript	JavaScript (ES5) vs ES6	Summary\n- ES6 (2015) introduced major features atop ES5: `let`/`const`, arrow functions, classes, template literals, destructuring, spread/rest, modules (`import`/`export`), promises, default parameters.\n- Largely backward compatible; improves scoping, async handling, and code organization.	
F#r]86%E*(	Basic-66869	Interview Quesions::JavaScript	What is the Temporal Dead Zone	The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable with the let and const keywords, but not with var. The time span between the creation of a variable’s binding and its declaration, is called the temporal dead zone.\n\nExample\n```js\n// Access before declaration throws\n// console.log(a); // ReferenceError\nlet a = 1;\n```	
A9v{;c}-dj	Basic-66869	Interview Quesions::JavaScript	What is heap	Heap(Or memory heap) is the memory location where objects are stored when we define variables.	
mckQna;YlZ	Basic-66869	Interview Quesions::JavaScript	What is a microTask queue	Microtask queue processes tasks (e.g., promise callbacks) before the macrotask/callback queue between event loop ticks.\n```js\nsetTimeout(() => console.log('macro'), 0);\nPromise.resolve().then(() => console.log('micro'));\n// Output: micro, macro\n```	
go^E&z*,T9	Basic-66869	Interview Quesions::JavaScript	What is babel	Babel is a JavaScript transpiler to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments	
nZqel6X)2V	Basic-66869	Interview Quesions::JavaScript	What is the difference between Function constructor (new Function) and function declaration	`new Function` creates functions in the global scope and does not close over local variables; declarations/expressions do close over outer scopes.\n```js\nfunction outer() {\n const secret = 1;\n const f1 = function () { return secret; }; // closes over secret\n const f2 = new Function('return typeof secret'); // 'undefined'\n return [f1(), f2()];\n}\nconsole.log(outer()); // [1, 'undefined']\n```	
G~0z.k{&dh	Basic-66869	Interview Quesions::JavaScript	What is the difference between function and class declaration	Hoisting\n- Function declarations are hoisted.\n- Class declarations are hoisted but not initialized; accessing before definition throws.\n```js\nfoo(); // ok\nfunction foo() {}\n\n// new Bar(); // ReferenceError: Cannot access 'Bar' before initialization\nclass Bar {}\n```	
i]I,Q{rAlj	Basic-66869	Interview Quesions::JavaScript	What are the different kinds of generators	Kinds\n- Generator function declaration\n- Generator function expression\n- Generator method in object literal\n- Generator method in class\n- Computed property generator (e.g., `Symbol.iterator`)\n```js\nfunction* decl() { yield 1; yield 2; }\nconst expr = function* () { yield 1; yield 2; };\nconst obj = { *gen() { yield 1; yield 2; } };\nclass C { *gen() { yield 1; yield 2; } }\nconst iterObj = { *[Symbol.iterator]() { yield 1; yield 2; } };\nconsole.log(Array.from(iterObj)); // [1, 2]\n```	
s<_},]>oRd	Basic-66869	Interview Quesions::JavaScript	What is the difference between setTimeout, setImmediate and process.nextTick?	Node.js\n- `setTimeout(cb, ms)`: schedule after delay (macrotask).\n- `setImmediate(cb)`: schedule after current poll phase completes (macrotask, often after I/O).\n- `process.nextTick(cb)`: schedule microtask; runs before other queued work — use sparingly to avoid starvation.	
OT)=[.-|$s	Basic-66869	Interview Quesions::JavaScript	debounce vs throttle	Definitions\n- Debounce: delay execution until events stop for `n` ms.\n- Throttle: execute at most once every `n` ms during a burst of events.\n```js\nfunction debounce(fn, wait) {\n let t;\n return (...args) => {\n clearTimeout(t);\n t = setTimeout(() => fn(...args), wait);\n };\n}\nfunction throttle(fn, wait) {\n let last = 0;\n return (...args) => {\n const now = Date.now();\n if (now - last >= wait) { last = now; fn(...args); }\n };\n}\n```	
j<cP[%<ZSO	Basic-66869	Interview Quesions::JavaScript	"""1"" + true - ""1"""	```js\n'1' + true; // '1true' (string concatenation)\n'1true' - '1'; // NaN (numeric subtraction on non-numeric string)\n```	
idh*]GpS!<	Basic-66869	Interview Quesions::JavaScript	"const a = ""abc"" a[2] = ""d"" console.log(a);"	```js\nconst a = 'abc';\na[2] = 'd';\nconsole.log(a); // 'abc' — strings are immutable\n```	
jUcLeHGnnA	Basic-66869	Interview Quesions::JavaScript	const obj = { name: 'Quang', // showName: function () {} showName(age) { // method console.log(`123 ${this.name} ${age}`); } } const showName = obj.showName; showName();	```js\nconst person = { name: 'Anna' };\nconst obj = {\n name: 'Quang',\n showName(age) { console.log(`123 ${this.name} ${age}`); }\n};\nconst showName = obj.showName;\nshowName(); // 123 undefined undefined — plain call, undefined this\n\nshowName.call(person, 23); // 123 Anna 23\nshowName.apply(person, [23]); // 123 Anna 23\n```	
is?vWdm;EP	Basic-66869	Interview Quesions::JavaScript	Arrow function vs function declaration. Give Example	Key differences\n- Arrow functions: lexical `this`, no `arguments`, not constructible.\n- Regular functions: own `this`, have `arguments`, constructible with `new`.\n```js\nconst arrow = (...args) => args.length;\nfunction regular() { return arguments.length; }\n\nconsole.log(arrow(1,2)); // 2\nconsole.log(regular(1,2)); // 2\n\n// new arrow(); // TypeError: arrow is not a constructor\nfunction C() {}\nnew C(); // ok\n```	
Ncgx-}+!hR	Basic-66869	Interview Quesions::JavaScript	Bubbling and Capturing	"Bubbling and capturing (javascript.info) Bubbling and capturing describe the two phases of event propagation in the DOM when an event occurs on an element with ancestors. Bubbling (default): The event starts at the target element and then ""bubbles"" upwards through its parent elements in the DOM hierarchy, triggering event listeners attached to those ancestors along the way. Capturing: The event starts at the root of the DOM and ""captures"" downwards through the ancestors to the target element, triggering event listeners attached to those ancestors before reaching the target. Capturing is enabled by passing true as the third argument to addEventListener(). Both phases contribute to the event flow, allowing for flexible event handling and techniques like event delegation. Capturing happens before bubbling in Event Propagation If event.stopPropagation() is called during the capturing phase, then the event travel stops, no bubbling will occur. Non-bubbling events such as focus, blur, load can be handled by Capturing"	
mQQ}XK2yh$	Basic-66869	Interview Quesions::JavaScript	[Array] iterative methods and empty slots	"iterative methods: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#iterative_methods iterative methods behave differently with empty slots sparse arrays: Arrays can contain ""empty slots"" -> Array methods and empty slots: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array_methods_and_empty_slots"	
c3{N:m-cw/	Basic-66869	Interview Quesions::JavaScript	CommonJS vs ESM	CommonJS (CJS) uses synchronous require() and module.exports syntax, designed for Node.js, while ECMAScript Modules (ESM) use asynchronous import and export syntax, serving as the official JavaScript standard and supporting native browser environments and Node.js. The main distinctions are their syntax, synchronous vs. asynchronous module loading, and compatibility with different environments. ESM is the future standard, offering benefits like tree shaking and better performance, while CommonJS is still prevalent in the existing Node.js ecosystem. CommonJS (CJS) Syntax: Uses require() to import modules and module.exports to export them. Loading: Loads modules synchronously, which can block execution until the module is loaded. Environment: Primarily used in Node.js. Characteristics: Has been the long-standing standard for server-side JavaScript in Node.js. Provides Node-specific variables like **dirname and **filename. ECMAScript Modules (ESM) Syntax: Uses import and export keywords for module management. Loading: Supports asynchronous loading, enabling better parallelism. Environment: Natively supported in modern web browsers and modern Node.js environments. Characteristics: The official, standardized module system for JavaScript. Enables static analysis of dependencies, leading to more efficient tree shaking (dead code elimination). More suitable for modern web applications due to native browser support and performance benefits. Key Differences at a Glance Feature CommonJS (CJS) ECMAScript Modules (ESM) Syntax require() and module.exports import and export Loading Synchronous Asynchronous Standard De facto standard for Node.js Official JavaScript standard Browser Support Not native Native When to Use Which Use CommonJS for: Older Node.js projects or environments where it's the established standard and you prioritize simplicity. Use ESM for: Modern web applications, new Node.js projects, and situations where you need better performance, native browser support, and advanced features like tree shaking.	
E>Br&4AKXa	Basic-66869	Interview Quesions::JavaScript	var vs let vs const	"In JavaScript, var, let, and const are keywords used to declare variables, each with distinct characteristics regarding scope, reassignment, and hoisting. 1. Scope: var: Variables declared with var have function scope or global scope. This means they are accessible throughout the entire function in which they are declared, or globally if declared outside any function.let: Variables declared with let have block scope. They are only accessible within the specific block (e.g., if statements, for loops, or any curly braces {}) where they are defined.const: Similar to let, const also provides block scope. 2. Reassignment: var: Variables declared with var can be reassigned and redeclared within the same scope. let: Variables declared with let can be reassigned, but they cannot be redeclared within the same block scope. const: Variables declared with const cannot be reassigned after their initial assignment. They are used to declare constants or read-only references. However, if a const variable holds an object or array, its properties or elements can be modified, but the variable itself cannot be pointed to a different object or array. 3. Hoisting: var: Variables declared with var are hoisted to the top of their function or global scope. This means they can be accessed before their declaration, though their value will be undefined until the actual assignment. let and const: Variables declared with let and const are also hoisted, but they are subject to the ""Temporal Dead Zone"" (TDZ). This means accessing them before their declaration will result in a ReferenceError. In summary: Use const for values that should not change throughout the program's execution.Use let for variables whose values might need to be reassigned later in the code.Avoid using var in modern JavaScript development due to its less predictable scoping behavior, which can lead to unexpected bugs. let and const offer more controlled and intuitive variable declaration."\n\nEvent capturing goes top-down (document → target); bubbling goes bottom-up (target → document). You can choose phase with the third parameter of `addEventListener`:\n```js\nel.addEventListener('click', handler, { capture: true }); // capture phase\nel.addEventListener('click', handler); // bubble phase (default)\n```	
Os!i<T1O?9	Basic-66869	Interview Quesions::NodeJS	What is Node.js? / How does Node.js work?	Node.js is an open-source server side runtime environment built on Chrome's V8 JavaScript engine. It provides an event driven, non-blocking (asynchronous) I/O and cross-platform runtime environment for building server-side applications using JavaScript.	
onRlW9)!&I	Basic-66869	Interview Quesions::NodeJS	Node.js vs Browser JavaScript	Node.js is a runtime environment for executing JavaScript code on the server-side, while browser JavaScript is a runtime environment for executing JavaScript code in web browsers.\n\nNode.js runs in a single thread, while browser JavaScript runs in multiple threads.\n\n- Runtime\n - Node.js runs JavaScript on the server; browsers run it in the client.\n - Both execute JavaScript on a single main thread.\n- Event loop\n - Node: Powered by libuv . Offloads I/O (FS, DNS, zlib, some crypto) to the kernel or the libuv thread pool (default 4 threads), then queues callbacks back to the main JS thread. This makes I/O appear concurrent without multithreaded JS.\n - Browser: Event loop is integrated with rendering and input queues. Long-running JS blocks rendering and user interactions, causing UI freezes.\n- “Multithreading”\n - Node: JS itself is single-threaded, but the runtime uses extra threads for I/O under the hood. For CPU-bound work, use worker_threads .\n - Browser: Main JS thread is single-threaded; other threads handle rendering, networking, and GC. Use Web Workers for heavy computation off the main thread.\n- Practical implications\n - Node: Never block the event loop; use async I/O (callbacks, promises, async / await ) and offload CPU-bound work to workers.\n - Browser: Keep tasks small to maintain UI responsiveness; rely on async APIs and Web Workers for heavy tasks.\n- Summary\n - Node: Single-threaded JS + libuv thread pool for I/O → efficient concurrency for I/O-heavy workloads.\n - Browser: Single main JS thread + rendering/UI constraints → prioritize non-blocking code and off-main-thread computation for smooth UX.	
n==/`?wf|k	Basic-66869	Interview Quesions::NodeJS	What is Node.js Single Process Model?	Node.js runs in a single process and the application code runs in a single thread and thereby needs less resources than other platforms. This single thread doesn't have to wait for the request to complete and is free to handle the next request.	
F|xw,Dj$}*	Basic-66869	Interview Quesions::NodeJS	What are the data types in Node.js?	Just like in JavaScript, Node.js has two broad categories of data types:\n\n- Primitives: `string`, `number`, `bigint`, `boolean`, `undefined`, `null`, `symbol`.\n- Objects: `Object`, `Function`, `Array`, and Node-specific `Buffer`.\n\nNode.js includes an additional data type called `Buffer` (not available in browser JavaScript). Buffers store binary data, commonly used for file I/O and network packets.\n\nExample:\n\n```js\nconst buf = Buffer.from('hello');\nconsole.log(buf); // <Buffer 68 65 6c 6c 6f>\n```	
O$6KfOi?mb	Basic-66869	Interview Quesions::NodeJS	How to create a simple server in Node.js that returns Hello World?	1) Create a project directory and enter it:\n\n```bash\nmkdir myapp\ncd myapp\n```\n\n2) Initialize the project:\n\n```bash\nnpm init -y\n```\n\nOptionally set the entry point to `app.js`.\n\n3) Install Express:\n\n```bash\nnpm install express\n```\n\n4) Create `app.js`:\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n res.send('Hello World!');\n});\n\napp.listen(3000, () => {\n console.log('Example app listening on port 3000!');\n});\n```\n\n5) Run the app:\n\n```bash\nnode app.js\n```	
bOVw[uO?5`	Basic-66869	Interview Quesions::NodeJS	What does the runtime environment mean in Node.js?	The Node.js runtime is the software stack responsible for installing your web service's code and its dependencies and running your service. The runtime environment is literally just the environment your application is running in. This can be used to describe both the hardware and the software that is running your application. How much RAM, what version of node, what operating system, how much CPU cores, can all be referenced when talking about a runtime environment.	
kDoIQ1/>X,	Basic-66869	Interview Quesions::NodeJS	Explain usage of NODE_ENV?	`NODE_ENV` is an environment variable commonly used to control configuration (e.g., `development`, `production`). Your app can check its value and change behavior accordingly.\n\nExample:\n\n```bash\nNODE_ENV=production node app.js\n```\n\n```js\nif (process.env.NODE_ENV === 'production') {\n // enable production optimizations\n}\n```	
IOJrD=O3%#	Basic-66869	Interview Quesions::NodeJS	What are the core modules of Node.js?	They are defined within the Node.js source and are located in the lib/ folder, and Node.js has several modules compiled into the binary such as fs, os, path, util, http	
q45q2r`Kir	Basic-66869	Interview Quesions::NodeJS	What is callback function in Node.js?	In node.js, we basically use callbacks for handling asynchronous operations like — making any I/O request, database operations or calling an API to fetch some data. Callback allows our code to not get blocked when a process is taking a long time.	
ufeuyTT.qs	Basic-66869	Interview Quesions::NodeJS	How assert works in Node.js?	In Node.js, assert is used to write tests. It only provides feedback only when any of the running test cases fails. This module was built to be used internally by Node.js.	
P@l8LiU[Y3	Basic-66869	Interview Quesions::NodeJS	What is an error-first callback?	Error-first callbacks use the signature `(err, data)`. If an error occurs, `err` is non-null and should be handled; otherwise `data` contains the result.\n\nExample:\n\n```js\nconst fs = require('fs');\n\nfs.readFile('file.json', (err, data) => {\n if (err) {\n console.error(err);\n return;\n }\n console.log(data);\n});\n```	
QTRuLUy^0O	Basic-66869	Interview Quesions::NodeJS	List down the major benefits of using Node.js?		
LGZq=`VN|4	Basic-66869	Interview Quesions::NodeJS	What is package.json?	The package.json file in Node.js is the heart of the entire application. It is basically the manifest file that contains the metadata of the project where we define the properties of a package.	
sdl{VQt)i~	Basic-66869	Interview Quesions::NodeJS	What do you understand by Event-driven programming?	That means instead of waiting for a response javascript will keep executing while listening for other events.	
vefp?mfIG*	Basic-66869	Interview Quesions::NodeJS	What is an Event loop in Node.js and how does it work?	The Node.js event loop enables non-blocking I/O on a single thread. Async tasks are offloaded (via `libuv`) and their callbacks are queued for later execution.\n\n- Core components:\n - Call Stack: executes synchronous code (LIFO).\n - `libuv`: handles OS-level async I/O, timers, thread-pool work.\n - Callback queues: separate queues per phase (timers, I/O, check, close).\n - Microtask queues: `process.nextTick` and Promise callbacks (higher priority).\n\n- Event loop phases (simplified order):\n - Timers: `setTimeout`, `setInterval`.\n - Pending Callbacks: system-level callbacks from previous cycle.\n - Idle/Prepare: internal.\n - Poll: I/O events; may block waiting for new events.\n - Check: `setImmediate` callbacks.\n - Close Callbacks: e.g., `socket.on('close')`.\n\n- Microtasks priority:\n - After each phase and after initial sync code, drain `process.nextTick` and Promise microtasks completely before moving on.\n\nExample:\n\n```js\nconsole.log('Start');\n\nsetTimeout(() => {\n console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n console.log('Promise');\n});\n\nsetImmediate(() => {\n console.log('setImmediate');\n});\n\nconsole.log('End');\n```\n\nTypical output:\n\n- `Start`\n- `End`\n- `Promise` (microtask)\n- `setTimeout` (timers phase) or `setImmediate` (check phase) — order can vary depending on system conditions; `setImmediate` always runs in the check phase.	
Q`~d`4(wBr	Basic-66869	Interview Quesions::NodeJS	Explain REPL in the context of Node.js.	REPL in Node.js stands for Read, Eval, Print, and Loop. It represents a computer environment such as a window console or Unix/Linux shell where any command can be entered and then the system can respond with an output. Node.js comes bundled with a REPL environment by default. REPL can perform the below-listed tasks:Read: Reads the user’s input, parses it into JavaScript data-structure and then stores it in the memory.Eval: Receives and evaluates the data structure.Print: Prints the final result.Loop: Loops the provided command until CTRL+C is pressed twice.	
O8t&HxGM3m	Basic-66869	Interview Quesions::NodeJS	What is module in Node.js?	Modules refer to small units of independent, reusable code. It is used to encapsulate all the related codes or functions into a single file.	
dhvn/6eO_k	Basic-66869	Interview Quesions::NodeJS	Explain libuv.	Libuv is a multi-platform support library of Node.js which majorly is used for asynchronous I/O. A few of the important features of libuv are event loop, Asynchronous file & network operations. FYI, it also supports to handle the child processes	
o66NWX}9(8	Basic-66869	Interview Quesions::NodeJS	Explain the purpose of ExpressJS package?	Express.js is a framework built on top of Node.js that facilitates the management of the flow of data between server and routes in the server-side applications. Express.js is developed on the middleware module of Node.js called connect. The connect module further makes use of http module to communicate with Node.js.	
v~cVm*8B`d	Basic-66869	Interview Quesions::NodeJS	Differentiate between process.nextTick() and setImmediate()?	Similarities:\n- Both schedule callbacks asynchronously.\n\nDifferences:\n- `process.nextTick`: runs before the next event loop phase (microtask queue), often immediately after current operation finishes.\n- `setImmediate`: runs in the "check" phase, after I/O events in the current loop iteration.	
GD*SDh?Cn4	Basic-66869	Interview Quesions::NodeJS	How does Node.js handle the child threads?	In general, Node.js is a single threaded process and doesn’t expose the child threads or thread management methods. But you can still make use of the child threads for some specific asynchronous I/O tasks which execute in the background.	
DdL6]^9eKy	Basic-66869	Interview Quesions::NodeJS	Explain stream in Node.js along with its various types.	Streams let you process data chunk-by-chunk without loading it all into memory. Useful for large files and network data.\n\nTypes:\n- Readable: read from a source.\n- Writable: write to a destination.\n- Duplex: both read and write.\n- Transform: duplex that transforms data as it passes through.	
x+qX={hW:	Basic-66869	Interview Quesions::NodeJS	List down the various timing features of Node.js.	Reference: https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick\n\nTiming APIs:\n- `setTimeout` / `clearTimeout`: run after N milliseconds.\n- `setInterval` / `clearInterval`: run repeatedly every N milliseconds.\n- `setImmediate` / `clearImmediate`: run in the event loop "check" phase.\n- `process.nextTick`: run before the next event loop phase (microtask queue).	
nh{/j`:{h2	Basic-66869	Interview Quesions::NodeJS	What do you understand by an Event Emitter in Node.js?	EventEmitter is a Node.js class that includes all the objects that are capable of emitting events. These objects contain an eventEmitter.on() function which can attach more than one function to the named events that are emitted by the object. Whenever an EventEmitter object throws an event (use evenEmitter.emit()), all the attached functions to that specific event are invoked synchronously.	
ck!%(J[b<<	Basic-66869	Interview Quesions::NodeJS	Module resolution and node_modules scanning	For `require('foo')`, Node.js searches `node_modules` directories starting from the current folder up through parent directories until the filesystem root.\n\nExample search order for `/home/user/project/app.js` requiring `bar`:\n- `/home/user/project/node_modules/bar`\n- `/home/user/node_modules/bar`\n- `/home/node_modules/bar`\n- `/node_modules/bar`	
JTrq&Lbe,S	Basic-66869	Interview Quesions::NodeJS	File-Based Module characteristic	Characteristics:\n- Conditional loading: `require` can be called inside code paths.\n- Blocking: `require` is synchronous; it blocks until the module loads.\n- Caching: modules are cached by resolved path after first load; subsequent `require` returns the cached `module.exports`.	
iUMzXO(8Ml	Basic-66869	Interview Quesions::NodeJS	Types of modules? The require order?	- Core module: `require('fs')`\n- File-based module: `require('../foo')`\n- Folder-based module: `require('../foo')`, `require('../foo/index')`\n- Module in `node_modules`: `require('foo')`\n- Folder with `package.json` and `main` field\n- Folder with `index.js`\n\nIf more than one case matches, the priority follows the above order.	
Jop|IV]kWN	Basic-66869	Interview Quesions::NodeJS	main vs exports in package.json	In `package.json`, these fields define how consumers resolve your package:\n\n- `main`: CommonJS entry point (`require()` in Node).\n- `module`: ES module entry (used by bundlers supporting ESM).\n- `browser`: browser-specific entry or file map overrides.\n- `types` (or `typings`): TypeScript declaration file path.\n- `exports`: modern field for conditional and subpath exports; takes precedence over `main`/`module` when present.\n\nHighlights of `exports`:\n- Conditional exports: different files for `node`, `browser`, `import`, `require`.\n- Subpath exports: expose controlled internal files.\n- Encapsulation: hide files not exported.\n\nFallback/priority (simplified):\n- `exports` > `browser` > `module` > `main`\n- `types` resolution may be specified in `exports` conditions; otherwise top-level `types` applies.	
0et0}@IR,]	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between an id and a class in HTML/CSS?	An id is a unique identifier for a single HTML element.\nA class is a reusable identifier that can be applied to multiple elements.\n\nIn CSS, an id is selected using the `#` symbol, while a class is selected using the `.` symbol.	
a!hfOCYM!!	Basic-66869	Interview Quesions::HTML/CSS	Can you explain the box model in CSS?	The CSS box model describes the rectangular boxes generated for elements in the DOM. The box model is composed of the following layers:\n\n1. Content: The innermost part, where text and images appear.\n\n2. Padding: The space between the content and the border.\n\n3. Border: The outer edge of the padding, surrounding the element.\n\n4. Margin: The space outside the border, separating the element from others.	
N!|Y0|U?|a	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between inline, inline-block, and block elements?	In CSS, the difference between inline, inline-block, and block elements is on the way they’re rendered in the web page:\n\nInline: Inline elements don’t have a width or height.\nThey don’t start on a new line and take up only the width that’s required (based on their content).\nExamples: `<span>`, `<a>`.\n\nInline-block: Do not start on a new line, but allow you to set height and width.\nExample: `<img>`.\n\nBlock: Elements start on a new line, taking up the full width available by default.\nTheir width and height can be set.\nExamples: `<div>`, `<p>`.	
M{HCKbf4gg	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between the em and rem units?	They’re both relative units of measurement, however, they’re relative to different things:\n\n“em” units are relative to the font size of their parent element. So if the parent element has a font size of 20px, then setting a “2em” font size, would equal to 40px.\n\n“rem” units are “root em”, which means they’re relative to the web page’s root element (the `<html>` element).	
T.F]!|Pt]=	Basic-66869	Interview Quesions::HTML/CSS	Flexbox vs Grid vs Box Layout	Flexbox is a one-dimensional layout model that arranges items in a row or a column. It’s best used for smaller layout changes, like aligning items in a navigation bar or a footer.\n\nGrid is a two-dimensional layout model that arranges items in rows and columns. It’s best used for larger layout changes, like creating a responsive grid layout for a website.\n\nBox Layout is the default layout model in CSS. It’s based on the box model, where each element is a rectangular box. It’s best used for simple layouts, like centering an element on the page.	
1;F_A1PB2H	Basic-66869	Interview Quesions::HTML/CSS	Can you explain CSS specificity and how it works?		
Sqtsume:j!	Basic-66869	Interview Quesions::HTML/CSS	What are media queries?		
wS1usH;.%,	Basic-66869	Interview Quesions::HTML/CSS	Explain some of the pros and cons for CSS animations versus JavaScript animations.	Use CSS animations for simpler “one-shot” transitions, like toggling UI element states.\nUse JavaScript animations when you want advanced effects like bouncing, stop, pause, rewind, or slowing down.\nIf you choose to animate with JavaScript, use the Web Animations API or a modern framework you’re comfortable with.	
I=(rs!mcK2	Basic-66869	Interview Quesions::HTML/CSS	"Css Selector: ~, >, +, #, ."	```css\ndiv p /* Selects all <p> elements inside <div> elements */\np.intro /* Selects all <p> elements with class="intro" */\n#firstname /* Selects the element with id="firstname" */\n.name1.name2 /* Selects elements with both name1 and name2 classes */\n.name1 .name2/* Selects descendants with name2 under an element with name1 */\ndiv > p /* Selects <p> elements whose parent is a <div> */\ndiv + p /* Selects the first <p> immediately after a <div> */\np ~ ul /* Selects all <ul> elements placed after a <p> */\n```\n\nReference: CSS Selectors Reference (w3schools.com).	
d:7nK*Ymy9	Basic-66869	Interview Quesions::HTML/CSS	css vs css-in-js		
zWjYlzDs.H	Basic-66869	Interview Quesions::HTML/CSS	tailwindcss vs css		
BU66(j|7Q6	Basic-66869	Interview Quesions::HTML/CSS	sass vs postcss		
JKE3#s;N,~	Basic-66869	Interview Quesions::Operation System	What do you mean by an operating system?	An Operating System (OS) is system software that manages computer hardware and software resources and provides common services for programs.\n\n- Manages CPU, memory, storage, I/O devices, and processes.\n- Schedules tasks and allocates resources fairly and efficiently.\n- Provides abstractions (files, processes, threads) and security.\n- Acts as an intermediary between users/applications and hardware.	
uv|en.AHg$	Basic-66869	Interview Quesions::Operation System	Scheduling Algorithm	Common CPU scheduling algorithms:\n\n- FCFS (First Come First Serve): processes execute in arrival order; easy to implement (FIFO queue) but may have high average waiting time.\n- SJF/SJN (Shortest Job First/Next): runs the process with the smallest burst time; minimizes average waiting time; may cause starvation for long jobs.\n- Priority Scheduling: runs the highest priority process first; equal priorities use FCFS; risk of starvation for low-priority processes (can use aging).\n- SRTF (Shortest Remaining Time First): preemptive version of SJF; always runs the job with the shortest remaining time; good for short jobs; can preempt longer jobs.\n- Round Robin (RR): each process gets a fixed time slice (quantum); preempted after quantum expires; improves responsiveness in time-sharing systems.	
yrzG*5gt,9	Basic-66869	Interview Quesions::Operation System	Difference between Counting and Binary Semaphores	- Binary semaphore: takes values 0/1; used for mutual exclusion (mutex-like behavior).\n- Counting semaphore: holds a non-negative integer; controls access to a resource pool with multiple instances.\n- Binary semaphores are simpler and enforce exclusive access; counting semaphores manage capacity.	
F[`oHyR0#+	Basic-66869	Interview Quesions::Operation System	What is Deadlock?	Deadlock occurs when processes are blocked, each holding a resource and waiting for others to release theirs.\n\nNecessary conditions (Coffman):\n- Mutual exclusion\n- Hold and wait\n- No preemption\n- Circular wait	
KlMh0bw.BW	Basic-66869	Interview Quesions::Operation System	Ram vs Cache	- Cache: very fast, small memory close to the CPU; stores frequently used data/instructions; organized in levels (L1/L2/L3).\n- RAM: larger main memory; stores programs and data currently in use; slower than cache but faster than disk.	
j$;a%oDmvF	Basic-66869	Interview Quesions::Operation System	Thread vs Process	- Process: an executing program with its own memory space.\n- Thread: lightweight execution unit within a process; shares process memory.	
Q-XGbT=@Ya	Basic-66869	Interview Quesions::Operation System	Multi-thread vs multi-process	- Multiprocessing: multiple processes (often across CPUs/cores) with isolated memory; improves parallelism and isolation; IPC required.\n- Multithreading: multiple threads within one process sharing memory; lower overhead; easier sharing; needs careful synchronization.	
z=/6B}uLg9	Basic-66869	Interview Quesions::Operation System	Virtual Memory (VM), VM paging and Page Fault	- Virtual Memory: abstraction that gives processes the illusion of a large, contiguous memory space; enables memory protection and isolation.\n- Paging: divides virtual memory into fixed-size pages mapped to physical frames; avoids external fragmentation.\n- Page Fault: occurs when a process accesses a page not in physical memory; OS loads the page from disk (swap/page file) into RAM.	
El7a?ezq/J	Basic-66869	Interview Quesions::Operation System	Ram vs Rom	- RAM (Random Access Memory): volatile; temporary working memory for active programs/data.\n- ROM (Read-Only Memory): non-volatile; permanently stores firmware/instructions.	
yHS9$RuksI	Basic-66869	Interview Quesions::Operation System	Solution to the Critical Section Problem	- A correct solution must satisfy:\n - Mutual Exclusion: only one process in the critical section at a time.\n - Progress: if no process is in the critical section, selection of the next entrant cannot be postponed indefinitely.\n - Bounded Waiting: each process has a bounded waiting time before entering the critical section.	
eY:H2@%.4	Basic-66869	Interview Quesions::General	Semantic Versioning	Semantic versioning means versioning your software in a way that the version numbers have significant meaning.\nNode.js developers follow a three-digit versioning scheme: `MAJOR.MINOR.PATCH`.	
hN8B`-(Jk+	Basic-66869	Interview Quesions::General	Optimistic UI Design	Updates the UI based on predictable states immediately, without waiting for the data response.\nThe response time should be less than 2 seconds.	
N^VAY=#;8?	Basic-66869	Interview Quesions::General	Atomic design methodology	Atomic design is a methodology composed of five distinct stages working together to create interface design systems in a more deliberate and hierarchical manner.\n\nThe five stages of atomic design are:\n- Atoms: elemental UI building blocks.\n- Molecules: collections of atoms forming simple UI components.\n- Organisms: complex UI components composed of groups of molecules and/or atoms and/or other organisms.\n- Templates: place components into a layout and demonstrate the design’s underlying content structure.\n- Pages: apply real content to templates to demonstrate the final UI and test.	
xl$L(ll3{<	Basic-66869	Interview Quesions::General	What are Micro Frontends? Pros and cons	Micro frontends are a pattern where web application UIs are composed from semi-independent fragments.\nFragments can be built by different teams using different technologies.\n\nAdvantages:\n- Team scalability.\n- Strategic vs tactical focus.\n- Reusability.\n- Multiple frameworks.\n\nDisadvantages:\n- Complexity (communication, development, deployment).\n- No standards.\n- Increased payloads.	
BajKzoY8*c	Basic-66869	Interview Quesions::General	SQL vs noSQL database	SQL is the programming language used to interface with relational databases. NoSQL is a class of DBMs that are non-relational and generally do not use SQL.	
kUN[}Z<I0M	Basic-66869	Interview Quesions::General	Consistency, Availability and Partition Tolerance Trade offs	Tradeoff between consistency, availability, and latency exists even when there are no network partitions.\nReason for the tradeoff is that a high availability requirement implies that the system must replicate data.	
IrHPS@zxIm	Basic-66869	Interview Quesions::General	Monolith Repo?	An app architecture for managing multiple packages from your local file system within a singular top-level, root package.\nDependencies can be linked together, which is a better mechanism than `yarn link`.\nAll your project dependencies are installed together.	
x33bnAGIDa	Basic-66869	Interview Quesions::General	How do you handle state management in single-page applications?	Without a full framework or library like React or Vue.js, properly handling state management is not a trivial task.\n\nSome options available through the language itself are:\n\n- Global variables: Centralize state in global variables or a global object. This can become unmanageable for large applications and makes local state harder to maintain.\n- Module pattern: Encapsulate state and provide a clear API to manage it. Instantiate local instances for individual components.\n- Pub/Sub pattern: Decouple state changes using event-driven architecture. More complex, but flexible.\n- State management libraries: Use Redux or similar libraries even without frameworks.	
t@x*lA5n0K	Basic-66869	Interview Quesions::General	Popular State Managements	- Redux: predictable state container.\n- Zustand: state management using simplified Flux principles; store is a hook usable anywhere, no provider needed.\n- RxJS: library for reactive programming using Observables.\n- React Query: data-fetching library for React; handles fetching, caching, synchronizing, and updating server state.	
lyg>gf8Nk-	Basic-66869	Interview Quesions::General	How to write effective unit test	- Test small pieces of code in isolation.\n- Follow Arrange–Act–Assert.\n- Keep tests short and simple.\n- Cover happy path first, then test edge cases.\n- Write tests before fixing bugs.\n- Make them performant.\n- Keep them stateless and consistent.\n- Use descriptive names.	
ifN|rI<[%Q	Basic-66869	Interview Quesions::General	What is Bundler? Webpack vs Rollup vs Parcel		
C0,[2LZ@7Q	Basic-66869	Interview Quesions::General	CommonJS vs RequireJS (AMD) vs ES6 module	- CommonJS: synchronous module loading; browsers cannot use directly without transpiling.\n- AMD (RequireJS): asynchronous module loading; usable in browsers.\n- ES6 modules: native JS modules; both sync and async loading; older browsers need a transpiler like Babel.	
o?*gFk]U-l	Basic-66869	Interview Quesions::General	Webpack properties: entry, output, resolve, module, plugins	`npx webpack` takes an entry script as entry point and generates output as configured.\n\n- resolve: configure how modules are resolved.\n - alias: use aliases instead of relative import paths.\n - extensions: resolve extensions in order; use `'...'` to include defaults.\n- module: determine how different types of modules are treated.\n - rules: apply loaders or modify the parser when creating modules.\n- plugins: array of webpack plugins; allow different behavior between development and release builds.	
Ir#)rPdX<J	Basic-66869	Interview Quesions::General	Babel webpack plugins: @babel/core, @babel/plugin-transform-runtime, @babel/preset-env, @babel/preset-react		
z|37yN*TyO	Basic-66869	Interview Quesions::General	TypeScript configurations		
oWn$-@C,-u	Basic-66869	Interview Quesions::General	Monorepo vs MultiRepo	Should my component library be a monorepo? | Mae Capozzi's Blog	
|0!0CpBzT_	Basic-66869	Interview Quesions::General	What is tree shaking, and how does it help with the performance of a web application?	Tree shaking is a technique used in JavaScript module bundlers, like Webpack or Vite, to remove unused code from the final bundled output.\n\nMain benefits include:\n\n- Reduced bundle size: removes unused code, improves load times and reduces bandwidth usage.\n- Improved performance: smaller bundles parse and execute faster, improving responsiveness.\n- Better resource utilization: write modular code without unused dependencies bloating the final bundle.	
pI8_%h25(#	Basic-66869	Interview Quesions::General	Functional Programming	Functional programming builds software by composing pure functions, avoiding shared state, mutable data, and side effects.\nIt is declarative rather than imperative, and application state flows through pure functions.\nReference: Fundamentals of functional programming with React - LogRocket Blog.	
L<`X3^^)Qq	Basic-66869	Interview Quesions::General	OOP (Object-oriented programming)		
nHvEZ*!+FP	Basic-66869	Interview Quesions::General	Refactoring/Code Review	- Move code to where it most logically belongs.\n- Remove duplicate code.\n- Make names self-documenting.\n- Split methods into smaller pieces.\n- Re-arrange inheritance hierarchies.\nReference: Refactoring: clean your code.	
HTyE=OQv5s	Basic-66869	Interview Quesions::General	Code Review checklist	Should:\n- Identify obvious bugs.\n- Look for possible security issues.\n- Look for “clever” code that reduces readability or maintainability.\n- Check for code duplication.\n- Check for adherence to the team’s standardized process.\n- Check whether names are descriptive enough.\n- Look for possible performance improvements (expensive operations inside loops, excessive object allocations, inefficient string concatenations, inefficient logging).\n- Check the presence and quality of tests:\n - Presence: Did the author create tests for their change?\n - Quality: Do the tests effectively exercise the system under test and follow best practices?\n - Readability: Tests are documentation; they should be simple and easy to understand.\n - Naming: Are tests named according to the team’s convention and easy to understand?\n- Explain your changes.\n- Optional: add code documentation.\n\nShould not:\n- Focus on cosmetic concerns.\n- Rely on manual testing alone.\n- Mismatch standardized processes between different team members.\n\nReference: What You Need in a Code Review Checklist (& What You Don't) - LinearB.	
dL.QS0ur6j	Basic-66869	Interview Quesions::General	Test Driven Development (TDD) Cycle	1. Add a test.\n2. Run all tests; the new test should fail for expected reasons.\n3. Write the simplest code that passes the new test.\n4. Run all tests; they should now pass.\n5. Refactor as needed, using tests after each refactor to ensure functionality is preserved.\n6. Repeat from step 1.\n\nDevelopment cycle:\n- Write tests first.\n- Each test case fails initially.	
IL>ndQ?-Zf	Basic-66869	Interview Quesions::General	What is API gateway?	An API gateway is an API management tool that sits between a client and a collection of backend services.\nIt acts as a reverse proxy to accept all API calls, aggregate the various services required to fulfill them, and return the appropriate result.\nWhen a client makes a request, the API gateway breaks it into multiple requests, routes them to the right places, produces a response, and keeps track of everything.\nReference: What does an API gateway do? (redhat.com).	
O)gkj,qXu:	Basic-66869	Interview Quesions::Design Patterns	Singleton Pattern	Share a single global instance throughout our application.\n\nIn React, we often rely on a global state through state management tools such as Redux or React Context instead of using Singletons.\nAlthough their global state behavior might seem similar to that of a Singleton, these tools provide a read-only state rather than the mutable state of the Singleton.	
u_nwd~iW?V	Basic-66869	Interview Quesions::Design Patterns	Proxy Pattern	Intercept and control interactions to target objects.\nProxy can help with validation, formatting, notifications, or debugging.\nThe two most common methods of Proxy handler are `get` and `set`.	
pP3h4;;xo<	Basic-66869	Interview Quesions::Design Patterns	Provider Pattern/Context API	Makes it possible to pass data to many components, without having to manually pass it through each component layer.	
(Pgm]fGAa	Basic-66869	Interview Quesions::Design Patterns	Export and Import in ES6	There are two different types of export: named and default.\nYou can have multiple named exports per module but only one default export.\nNamed exports are useful to export several values.\nDuring the import, it is mandatory to import them within curly braces with the same name of the corresponding object.\nBut a default export can be imported with any name.\n\nRe-Export/Aggregating (Export From):\n\n```js\nexport * from '…'; // does not set the default export\nexport * as name1 from '…'; // ECMAScript® 2020\nexport { name1, name2, nameN } from '…';\nexport { import1 as name1, import2 as name2, nameN } from '…';\nexport { default, /* others */ } from '…';\n```	
m*1(H_^I<$	Basic-66869	Interview Quesions::Design Patterns	Hook vs HOC	Best use-cases for a HOC:\nThe same, uncustomized behavior needs to be used by many components throughout the application.\nThe component can work standalone, without the added custom logic.\n\nBest use-cases for Hooks:\nThe behavior has to be customized for each component that uses it.\nThe behavior is not spread throughout the application; only one or a few components use the behavior.\nThe behavior adds many properties to the component.\n\nReference: HOC Pattern (patterns.dev)	
wU[uW_$?r~	Basic-66869	Interview Quesions::TypeScript	Generic Type	Generics let you parameterize types so they can be reused across different shapes.\n\nCommon generic utilities and examples:\n\n- `Array<ItemType>`\n- `Promise<ReturnedType>`\n- `Readonly<T>`\n- `Partial<T>`\n- `Record<KeyType, ValueType>`\n\nExample:\n\n```ts\nfunction wrap<T>(value: T): { data: T } {\n return { data: value };\n}\n\nconst r1 = wrap<string>('hello');\nconst r2 = wrap(123); // T is inferred as number\n```	
O.YxF`&i?.	Basic-66869	Interview Quesions::TypeScript	What are the primitive types in TypeScript?	- `string`, `number`, `boolean`, `bigint`, `symbol`, `null`, `undefined`.	
kn8xBaO07(	Basic-66869	Interview Quesions::TypeScript	What is any type, and when to use it?	- `any` disables type checking for a value. Use sparingly.\n- Implicit `any` can occur when the compiler cannot infer a type and no annotation is provided.\n- Prefer `unknown` or specific types to keep safety.	
K&oN:86Sv&	Basic-66869	Interview Quesions::TypeScript	What is void, and when to use the void type?	- `void` indicates a function returns no value.\n\n```ts\nfunction log(msg: string): void {\n console.log(msg);\n}\n```	
hht^kbbi|a	Basic-66869	Interview Quesions::TypeScript	What is an unknown type, and when to use it in TypeScript?	- `unknown` is a type-safe counterpart of `any`.\n- You can assign anything to `unknown`, but you must narrow it before using it.\n\n```ts\nfunction handle(input: unknown) {\n if (typeof input === 'string') {\n // narrowed to string\n console.log(input.toUpperCase());\n }\n}\n```	
d,FQ@[~uaq	Basic-66869	Interview Quesions::TypeScript	Note to Create Strongly typed Component Events and Event Handlers	- Inline event handlers often infer correct types automatically.\n- Named handlers may require explicit annotations.\n- Tip: hover handlers in your editor to see inferred types.\n\n```tsx\nfunction Input() {\n const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n console.log(e.key);\n };\n\n return <input type="text" onKeyDown={onKeyDown} />;\n}\n```	
q+B]J_`xvE	Basic-66869	Interview Quesions::TypeScript	"<input type=""text"" onKeyDown={e:React.KeyboardEvent<HTMLInputElement> => console.log(e.key)} /> What is wrong?"	You must wrap the parameter and annotation in parentheses.\n\nCorrect:\n\n```tsx\n<input\n type="text"\n onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => console.log(e.key)}\n/>\n```	
dsd,r&{3eh	Basic-66869	Interview Quesions::TypeScript	declare type for actions and dispatchs of redux-thunk	```ts\nimport { AnyAction } from 'redux';\nimport { ThunkAction, ThunkDispatch } from 'redux-thunk';\n\ntype AppState = { /* ... */ };\n\nexport type AppThunk<ReturnType = void> = ThunkAction<\n ReturnType,\n AppState,\n unknown,\n AnyAction\n>;\n\nexport type AppDispatch = ThunkDispatch<AppState, unknown, AnyAction>;\n```	
BLXGnxR].3	Basic-66869	Interview Quesions::TypeScript	declare enum type	```ts\nenum Status {\n Idle = 'idle',\n Loading = 'loading',\n Success = 'success',\n Error = 'error',\n}\n\nfunction setStatus(s: Status) {}\n\nsetStatus(Status.Loading);\n```	
mtG$I:ww}V	Basic-66869	Interview Quesions::Network & Security	Injection	- What: Untrusted user input is interpreted by the server and executed.\n- Impact: Data can be stolen, modified, or deleted.\n- Prevent:\n - Reject untrusted/invalid input data.\n - Use the latest framework.\n - Perform penetration tests.\n - Conduct security code reviews.	