#separator:tab
#html:false
#guid column:1
#notetype column:2
#deck column:3
#tags column:6
CXyf=jKNW+	Basic-66869	Interview Quesions::React	What are the features of React?	It uses the virtual DOM instead of the real DOM. It uses server-side rendering. It follows uni-directional data flow or data binding. It build the reusable/composable UI components to develop the view	
FoyA}$T9QX	Basic-66869	Interview Quesions::React	What do you know about the Virtual DOM?	- The Virtual DOM (VDOM) is an in-memory representation of Real DOM. - It starts as a copy of the real DOM. 3 Steps of Virtual DOM:\n\n1. Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.\n2. A diff is performed between the previous DOM and current DOM.\n3. Real DOM is updated with just the new changes.	
x7v|@{%0DI	Basic-66869	Interview Quesions::React	Differentiate between Real DOM and Virtual DOM		
cC3W]O5b<X	Basic-66869	Interview Quesions::React	What do you understand from “In React, everything is a component.”	Components are the building blocks of a React application’s UI. These components split up the entire UI into small independent and reusable pieces. Then it renders each of these components independent of each other without affecting the rest of the UI.	
x!BVn-%YPh	Basic-66869	Interview Quesions::React	Explain the purpose of render() in React.	Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component.	
xP@n:Hci!/	Basic-66869	Interview Quesions::React	How can you embed two or more components into one?	class MyComponent extends React.Component{ render(){ return( <div> <h1>Hello</h1> <Header/> </div> ); } } class Header extends React.Component{ render(){ return <h1>Header Component</h1> }; } ReactDOM.render( <MyComponent/>, document.getElementById('content') );	
tD#fA>`[%T	Basic-66869	Interview Quesions::React	What are Props?	Props are short hand for Properties in React. They are read-only components which must be kept pure i.e. immutable. They are always passed down from the parent to the child components throughout the application. A child component can never send a prop back to the parent component. This help in maintaining the unidirectional data flow and are generally used to render the dynamically generated data.	
bLvjjlaMiO	Basic-66869	Interview Quesions::React	What is a state in React and how is it used?	State of a component is an object that holds some information that may change over the lifetime of the component. State is similar to props, but it is private, mutable, and fully controlled by the component.	
s|1Jjpm@vg	Basic-66869	Interview Quesions::React	What are the different phases of React component’s lifecycle?	Mounting: The component is ready to mount in the browser DOM. This phase covers initialization from constructor(), getDerivedStateFromProps(), render(), and componentDidMount() lifecycle methods. Updating: In this phase, the component gets updated in two ways, sending the new props and updating the state either from setState() or forceUpdate(). This phase covers getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() and componentDidUpdate() lifecycle methods. Unmounting: In this last phase, the component is not needed and gets unmounted from the browser DOM. This phase includes componentWillUnmount() lifecycle method.	
j)Q37W1S~;	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillMount()	Executed just before rendering takes place both on the client as well as server-side.	
N>f,)5@dr3	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentDidMount()	Executed on the client side only after the first render.	
ho>RBCRWF0	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillReceiveProps()	Invoked as soon as the props are received from the parent class and before another render is called.	
vh)e2!`1]i	Basic-66869	Interview Quesions::React	Explain the lifecycle method shouldComponentUpdate()	Returns true or false value based on certain conditions. If you want your component to update, return true else return false. By default, it returns true.	
d5&3Sa#z}z	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillUpdate()	Called just before rendering takes place in the DOM.	
NQ2y}4fy!;	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentDidUpdate()	Called immediately after rendering takes place.	
bDPgrPkhAj	Basic-66869	Interview Quesions::React	Explain the lifecycle method componentWillUnmount()	Called after the component is unmounted from the DOM. It is used to clear up the memory spaces.	
m<ZO3o7eUB	Basic-66869	Interview Quesions::React	What is a synthetic event?	Synthetic events are the objects which act as a cross-browser wrapper around the browser’s native event. They combine the behavior of different browsers into one API. This is done to make sure that the events show consistent properties across different browsers. examples: onClick, onBlur, etc.	
p|p^V2r_Zd	Basic-66869	Interview Quesions::React	What are Higher Order Components(HOC)?	Put simply: just a React Component that wraps another one.Detailed explanation: Higher Order Component is an advanced way of reusing the component logic. Basically, it’s a pattern that is derived from React’s compositional nature. HOC are custom components which wraps another component within it. They can accept any dynamically provided child component but they won’t modify or copy any behavior from their input components. HOC are pure components and enable: 1. Code reuse, logic and bootstrap abstraction 2. Render Highjacking 3. State abstraction and manipulation 4. Props manipulation	
z)(}a@a$=*	Basic-66869	Interview Quesions::React	In which lifecycle event do you make AJAX requests and why?	AJAX requests should go in the componentDidMount lifecycle event. Reason: You can’t guarantee the AJAX request won’t resolve before the component mounts. If it did, that would mean that you’d be trying to setState on an unmounted component, which not only won’t work, but React will yell at you for. Doing AJAX in componentDidMount will guarantee that there’s a component to update.	
uJ}BIoh[@B	Basic-66869	Interview Quesions::React	How do you tell React to build in Production mode and what will that do?	Typically you’d use Webpack’s DefinePlugin method to set NODE_ENV to production. This will strip out things like propType validation and extra warnings. On top of that, it’s also a good idea to minify your code because React uses Uglify’s dead-code elimination to strip out development only code and comments, which will drastically reduce the size of your bundle.	
xq?sv-se$N	Basic-66869	Interview Quesions::React	What is JSX (JS XML)?	Basically it provides syntactic sugar for the React.createElement() function, giving us the simple ways to create React components with HTML like template syntax.	
OL!DT=<3S=	Basic-66869	Interview Quesions::React	What is React?	React is an open-source front-end JavaScript library that is used for building user interfaces, especially for single-page applications. It is used for handling view layer for web and mobile apps.	
L$ga}WG3v[	Basic-66869	Interview Quesions::React	What is the difference between state and props?	Props get passed to the component similar to function parameters whereas state is managed within the component similar to variables declared within a function.	
Ik1K8!QFj`	Basic-66869	Interview Quesions::React	"What is ""key"" prop?"	A key is a special string attribute you should include when creating arrays of elements. It helps React identify which items have changed, are added, or are removed.	
s09rc`.>(;	Basic-66869	Interview Quesions::React	What is context?	Context provides a way to pass data through the component tree without having to pass props down manually at every level.	
Ll)X1;&(:*	Basic-66869	Interview Quesions::React	What is reconciliation?	When a component's props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called reconciliation.	
Ix{-[~VBNX	Basic-66869	Interview Quesions::React	What are fragments?	It's a common pattern in React which is used for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.	
jrI~R6S+um	Basic-66869	Interview Quesions::React	What are error boundaries in React v16?	Error boundaries are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. A class component becomes an error boundary if it defines a new lifecycle method called componentDidCatch(error, info) or static getDerivedStateFromError()	
NS#J5g]Rh2	Basic-66869	Interview Quesions::React	What is the use of react-dom package?	The react-dom package provides DOM-specific methods that can be used at the top level of your app. Some of the methods of this package are:render(): Render a React element into the DOM in the supplied container and return a reference to the component (or returns null for stateless components).hydrate(): Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup.unmountComponentAtNode(): Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns true if a component was unmounted and false if there was no component to unmount.findDOMNode(): If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. In most cases, you can attach a ref to the DOM node and avoid using findDOMNode at all.createPortal(child, container): Creates a portal. Portals provide a way to render children into a DOM node that exists outside the hierarchy of the parent component.	
fI:#fODmB`	Basic-66869	Interview Quesions::React	What is ReactDOMServer?	The ReactDOMServer object enables you to render components to static markup (typically used on node server). This object is mainly used for server-side rendering (SSR). The following methods can be used in both the server and browser environments:renderToString()renderToStaticMarkup() For example, you call renderToString to render your root component to a string, which you then send as response.	
QnC1mCl>/.	Basic-66869	Interview Quesions::React	Why is a component constructor called only once?	React's reconciliation algorithm assumes that if a custom component appears in the same place on subsequent renders, it's the same component as before, so reuses the previous instance rather than creating a new one.	
x4PNquO)-1	Basic-66869	Interview Quesions::React	What are the common folder structures for React?	- Grouping by features or routes - Grouping by file type	
IEl=a.8`Zy	Basic-66869	Interview Quesions::React	What is the benefit of styles modules?	It is recommended to avoid hard coding style values in components. Any values that are likely to be used across different UI components should be extracted into their own modules.	
yX93pYzyV(	Basic-66869	Interview Quesions::React	What is React Router?	React Router is a routing-specific library that helps you add new screens and flows to your application quickly, while keeping the URL in sync with what's being displayed on the page. Some hook methods this library provides are useHistory, useLocation, useParams. It covers: Configuring RoutesNavigating with LinkUsing Nested Routes for LayoutNavigating programmaticallyUsing URL params and Search params	
BHB7^Vf4qD	Basic-66869	Interview Quesions::React	How React Router is different from history library?	React Router is a wrapper around the history library which handles interaction between the browser's window.history with its browser and hash histories. It also provides memory history which is useful for environments that don't have global history, such as mobile app development (React Native) and unit testing with Node.	
HZ`|B1)+3~	Basic-66869	Interview Quesions::React	What is React Interalization?	is part of FormatJS which provides bindings to React. It helps to format strings, dates, numbers, or pluralization	
JTC4IS2r3U	Basic-66869	Interview Quesions::React	What is Flux?	Flux is an application design paradigm used as a replacement for the traditional MVC pattern. It is not a framework or a library but a new kind of architecture that complements React and the concept of Unidirectional Data Flow. Facebook uses this pattern internally when working with React.	
D%yTdeOz31	Basic-66869	Interview Quesions::React	What is Redux?	Redux is a predictable state container for JavaScript apps based on the Flux design pattern. Redux can be used together with React, or with any other view library. Hook functions: useSelector, useDispatch	
L?3|K^p;nZ	Basic-66869	Interview Quesions::React	What are the core principles of Redux?	Redux follows three fundamental principles:Single source of truth: The state of your whole application is stored in an object tree within a single store. The single state tree makes it easier to keep track of changes over time and debug or inspect the application.State is read-only: The only way to change the state is to emit an action, an object describing what happened. This ensures that neither the views nor the network callbacks will ever write directly to the state.Changes are made with pure functions: To specify how the state tree is transformed by actions, you write reducers. Reducers are just pure functions that take the previous state and an action as parameters, and return the next state.	
nT}{UKCH@y	Basic-66869	Interview Quesions::React	What is the difference between mapStateToProps() and mapDispatchToProps()?	mapStateToProps() is a utility which helps your component get updated state (which is updated by some other components) mapDispatchToProps() is a utility which will help your component to fire an action event (dispatching action which may cause change of application state)	
cW0lc`wjNe	Basic-66869	Interview Quesions::React	Can I dispatch an action in reducer?	Your reducer should simply digest the action payload and returning a new state object. Adding listeners and dispatching actions within the reducer can lead to chained actions and other side effects.	
O|C$F95Ya-	Basic-66869	Interview Quesions::React	What is the difference between React context and React Redux?	Context is built in tool with React and required minimal setup, whereas Redux requires additional installation and extensive setup to integrate it with a React Application. Context is specifically designed for static data, that is not often refreshed or updated, whereas Redux is better in the high-frequency update data field. Context used for UI logic and State Management Logic are in the same component, whereas Redux has better code organization with separate UI logic and State Management Logic Redux ease to debug with Redux Dev Tool	
cO*hTP`t{X	Basic-66869	Interview Quesions::React	How to make AJAX request in Redux?	You can use redux-thunk middleware which allows you to define async actions.	
h[:7?W`BQ;	Basic-66869	Interview Quesions::React	What is the difference between component and container in React Redux?	Component is a class or function component that describes the presentational part of your application. Container is an informal term for a component that is connected to a Redux store. Containers subscribe to Redux state updates and dispatch actions, and they usually don't render DOM elements; they delegate rendering to presentational child components.	
yhp:KT%)!|	Basic-66869	Interview Quesions::React	What is redux-saga and its benifits?	redux-saga is a library that aims to make side effects (asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better. Benifits: - make asynchronous flows easy to read, write, and test - enable numerous approaches to tackling parallel execution, task concurrency, task racing, task cancellation, and more	
ltnzbOZ4mz	Basic-66869	Interview Quesions::React	What are the differences between call() and put() in redux-saga?	Both call() and put() are effect creator functions. call() function is used to create effect description, which instructs middleware to call the promise. put() function creates an effect, which instructs middleware to dispatch an action to the store.	
E))z6dtXj3	Basic-66869	Interview Quesions::React	What is Redux Thunk?	Redux Thunk middleware allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods dispatch() and getState() as parameters.	
h3pZ0Tf[Zs	Basic-66869	Interview Quesions::React	What are the differences between redux-saga and redux-thunk?	Both Redux Thunk and Redux Saga take care of dealing with side effects. In most of the scenarios, Thunk uses Promises to deal with them, whereas Saga uses Generators. Thunk is simple to use and Promises are familiar to many developers, Sagas/Generators are more powerful but you will need to learn them. But both middleware can coexist, so you can start with Thunks and introduce Sagas when/if you need them.	
D&@%=.daPO	Basic-66869	Interview Quesions::React	What are Redux selectors and why to use them?	Selectors are functions that take Redux state as an argument and return some data to pass to the component. These selectors have two main benefits,The selector can compute derived data, allowing Redux to store the minimal possible stateThe selector is not recomputed unless one of its arguments changes	
lQR+]!`<bS	Basic-66869	Interview Quesions::React	What is an action in Redux?	Actions are plain JavaScript objects or payloads of information that send data from your application to your store. Actions must have a type property that indicates the type of action being performed.	
K>1*eOxf5&	Basic-66869	Interview Quesions::React	What is reselect and how it works?	Reselect is a selector library (for Redux) which uses same concept with Redux Selector. It was originally written to compute derived data from Redux-like applications state, and not recomputed unless one of it arguments changed. It supports to create a new selector which receive other selectors as argument.	
kI2bdErp*~	Basic-66869	Interview Quesions::React	What are Styled Components?	styled-components is a JavaScript library for styling React applications. It removes the mapping between styles and components, and lets you write actual CSS augmented with JavaScript.	
s<_LqmJ_tz	Basic-66869	Interview Quesions::React	Do I need to keep all my state into Redux? Should I ever use react internal state?	It is up to the developer's decision. There are the some rules to determine what kind of data should be put into Redux Is the same data existed in store?Do other parts of the application care about this data?Do you need to be able to create further derived data based on this original data?	
tZuNHD4?q@	Basic-66869	Interview Quesions::React	What is the purpose of registerServiceWorker in React?	React creates a service worker for you without any configuration by default. The service worker is a web API that helps you cache your assets and other files so that when the user is offline or on a slow network, he/she can still see results on the screen, as such, it helps you build a better user experience. It's all about adding offline capabilities to your site.	
C&Ugl6PT|A	Basic-66869	Interview Quesions::React	What is React memo function?	Class components can be restricted from re-rendering when their input props are the same using PureComponent or shouldComponentUpdate. Now you can do the same with function components by wrapping them in React.memo.	
sdfVTRnIMW	Basic-66869	Interview Quesions::React	What is React lazy function?	The React.lazy function lets you render a dynamic import as a regular component. It will automatically load the seperated bundle containing the imported component when the component gets rendered. The module must be a default export containing a React component.	
Qv$v0hsu4H	Basic-66869	Interview Quesions::React	What are hooks? What rules need to be followed for hooks?	Hooks is a new feature(React 16.8) that lets you use state and other React features without writing a class. You need to follow two rules in order to use hooks,Call Hooks only at the top level of your react functions. i.e, You shouldn’t call Hooks inside loops, conditions, or nested functions.Call Hooks from React Functions or another hooks only.The naming convention of hooks should start with the prefix use	
d9>c:-w]`Y	Basic-66869	Interview Quesions::React	In which scenarios error boundaries do not catch errors?	Below are the cases in which error boundaries doesn't work:Inside Event handlers Asynchronous code using setTimeout or requestAnimationFrame callbacks During Server side rendering When errors thrown in the error boundary code itself	
kN0oYYZvfJ	Basic-66869	Interview Quesions::React	What is the proper placement for error boundaries?	- You can wrap top-level route components to display a generic error message for the entire application. - You can also wrap individual components in an error boundary to protect them from crashing the rest of the application and create the error state for each of components independently	
9E/elaX9]	Basic-66869	Interview Quesions::React	What is the methods order when component re-rendered?	An update can be caused by changes to props or state. The below methods are called in the following order when a component is being re-rendered.static getDerivedStateFromProps()shouldComponentUpdate()render()getSnapshotBeforeUpdate()componentDidUpdate()	
Mm_cR69)FD	Basic-66869	Interview Quesions::React	What are the methods invoked during error handling?	Below methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.static getDerivedStateFromError()componentDidCatch()	
Hep+>5!.c>	Basic-66869	Interview Quesions::React	What is the purpose of unmountComponentAtNode method?	This method is available from react-dom package and it removes a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns true if a component was unmounted and false if there was no component to unmount.	
NGBh@8n]?	Basic-66869	Interview Quesions::React	What is NextJS and major features of it?	Next.js is a popular and lightweight framework for static and server‑rendered applications built with React. It also provides styling and routing solutions. Below are the major features provided by NextJS,Server-rendered by defaultAutomatic code splitting for faster page loadsSimple client-side routing (page based)Webpack-based dev environment which supports (HMR)Able to implement with Express or any other Node.js HTTP serverCustomizable with your own Babel and Webpack configurations	
gA2?HOKfQ$	Basic-66869	Interview Quesions::React	Optimizing performance in a React application? List the React hook functions	Keeping component state local where necessary. (useState, useEffect)Split component to small ones if it becomes more complex.Avoid pass props down in many levels (State management: React-redux, useContext, useReducer)Memoizing React components to prevent unnecessary re-renders. (React.memo)Memoizing expensive React states or methods to reduce recomputation. (useMemo, useCallback)Building a custom hook to extract a logic into a reusable function Use refs to store mutable values without re-rendering the entire component.use debounce & throttle to avoid send multiple requests in a short time. Code-splitting in React using dynamic import()Windowing or list virtualizationLazy loading images	
QGo2Qir#W_	Basic-66869	Interview Quesions::React	React vs Angular	React is a library, but Angular is a Full-featured Framework. The virtual DOM and one-way data binding are used by React.js, but the real DOM and two-way data binding are used by Angular.	
ENY(b|8)-X	Basic-66869	Interview Quesions::React	How to write unit tests for custom hooks?	We would use react-hooks-testing-library write the unit test. There are two methods we need to know: renderHook: The renderHook can render custom hook, you can operations the custom hook like in the component.act: The act can execute the methods return from custom hook that makes sure all updates have been processed Reference: React | Write a unit test for custom hooks in ten minutes - DEV Community	
Mh[jf[d7|q	Basic-66869	Interview Quesions::React	What is React Testing Library?	React Testing Library is a set of helpers builds on top of DOM Testing Library that let you test React components. This allows you to get your tests closer to using your components the way a user will It's supported by CRA as default. Sample test steps: - Arrange (render): The method renders a React element into the DOM. - Act (fireEvent): The method allows you to fire events to simulate user actions. - Assert: assert that the test case is correct	
h!$Xko2UDE	Basic-66869	Interview Quesions::React	Testing Recipes in React components	Setup/Teardown (Arrange): setup a DOM element as a render target (beforeEach) or “clean up” and unmount the tree on exiting (afterEach) act / assert: makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions Rendering: test whether a component renders correctly for given props. Data Fetching: mock requests with dummy data Mocking Modules: Mocking out modules (ex: 3rd libraries) with dummy replacements Events: dispatching real DOM events on DOM elements Timers: You can use fake timers only in some tests Snapshot Testing: you save “snapshots” of the rendered component output ensure that a change is correct	
LY)5dv7=b:	Basic-66869	Interview Quesions::React	What are end-to-end tests?	End-to-end tests are useful for testing longer workflows, especially when they’re critical to your business (such as payments or signups). For these tests, you’d probably want to test how a real browser renders the whole app, fetches data from the real API endpoints, uses sessions and cookies, navigates between different links. We can assert on side effects not just in the browser, but potentially on the backend as well.	
Gyhl*=HSc`	Basic-66869	Interview Quesions::React	Recoil State management core concepts	Recoil is a state management library for React. Recoil lets you create a data-flow graph that flows from atoms (shared state) through selectors (pure functions) and down into your React components. Atoms are units of state that components can subscribe to. When an atom is updated, each subscribed component is re-rendered with the new value. Atoms can be used in place of React local component state. If the same atom is used from multiple components, all those components share their state. Selectors is a pure function that accepts atoms or other selectors as input. When these upstream atoms or selectors are updated, the selector function will be re-evaluated. Components can subscribe to selectors just like atoms, and will then be re-rendered when the selectors change. Popular components: - RecoilRoot​: Components that use recoil state need RecoilRoot to appear somewhere in the parent tree. A good place to put this is in your root component - Atom​: An atom represents a piece of state. Atoms can be read from and written to from any component. Components that read the value of an atom are implicitly subscribed to that atom, so any atom updates will result in a re-render of all components subscribed to that atom - Selector​: A selector represents a piece of derived state. Derived state is a transformation of state. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way - Components that need to read from and write to an atom should use useRecoilState() - We can use the useRecoilValue() hook to read the value of selector Getting Started | Recoil (recoiljs.org)	
c,l~8(c`.7	Basic-66869	Interview Quesions::React	Client Site Rendering (CSR), Server Site Rendering (SSR) and SSG (Static Site Generation)	- CSR: Server sending HTML and JS files -> Browser downloads JS -> Browser executes React -> Page full dynamic (loaded) - SSR: Server built out HTML page and sends to the browser -> Static HTML is rendered and Browser downloads JS in background (loaded) -> Loaded React adds interactivity to the page -> Page full dynamic - SSG: HTML files are generated on build time -> Static HTML is rendered and Browser downloads JS in background-> Loaded React adds interactivity to the page -> Page full dynamic Usage: - CSR: Login page, dashboard page, ... and the pages don't need SEO - SSR: page with dynamic data but still have SEO and expect super fast initial loading - SSG: for pages which don't need to be updated frequently and expect super fast initial loading	
ukjH*S<[!,	Basic-66869	Interview Quesions::React	How to Create a React Component Library	InitCreating ComponentsAdding TypescriptAdding RollupBuilding Your LibraryMore advances: Adding CSSOptimizingAdding TestsAdding StorybookAdding SCSS	
O^J|aZOs#P	Basic-66869	Interview Quesions::React	When should you memoize in React?	When should you memoize in React (prateeksurana.me)	
gEdvk}bCx<	Basic-66869	Interview Quesions::React	What is React Fiber?	Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM. Fiber improves the Virtual DOM and comparation steps of reconcilation algo	
q(a+%30cl2	Basic-66869	Interview Quesions::React	useState hook	- Returns a stateful value, and a function to update it. - During the initial render, the returned state (state) is the same as the value passed as the first argument (initialState). - Lazy initial state: The initialState argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render - The setState function is used to update the state. It accepts a new state value and enqueues a re-render of the component. - If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value. - During subsequent re-renders, the first value returned by useState will always be the most recent state after applying updates. - React guarantees that setState function identity is stable and won’t change on re-renders. This is why it’s safe to omit from the useEffect or useCallback dependency list. - Bailing out of a state update: If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects (React uses the Object.is comparison algorithm.) - Batching of state updates: React may group several state updates into a single re-render to improve performance.	
o[>+!Bp3;=	Basic-66869	Interview Quesions::React	useRef	useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component. The only difference between useRef() and creating a {current: ...} object yourself is that useRef will give you the same ref object on every render. Keep in mind that useRef doesn’t notify you when its content changes. Mutating the .current property doesn’t cause a re-render	
Nz8&|&mPsU	Basic-66869	Interview Quesions::React	React Profiler API	The Profiler measures how often a React application renders and what the “cost” of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from optimizations such as memoization.	
kd9Bf6FSN3	Basic-66869	Interview Quesions::React	When exactly does React clean up an effect?	React performs the cleanup when the component unmounts. However, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time.	
A<}Q3=<z&e	Basic-66869	Interview Quesions::React	useEffect	- By default, effects run after every completed render - Allow us Cleaning up an effect before the component is removed from the UI - if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect - Timing: useEffect is deferred until after the browser has painted (rendered) - Conditionally firing an effect + only be recreated when deps changes + If you pass an empty deps array, only be created after the intial rendered Practice challenge: https://www.greatfrontend.com/questions/javascript/use-query?framework=react&tab=coding https://react.dev/learn/synchronizing-with-effects	
0nio)!l~N	Basic-66869	Interview Quesions::React	useEffect vs useLayoutEffect	useEffect runs asynchronously after the browser paints, making it ideal for side effects that don't affect layout. useLayoutEffect runs synchronously before painting, perfect for DOM measurements or preventing visual flicker, but should be used sparingly as it blocks the browser's painting process	
J0~8W6;Q*@	Basic-66869	Interview Quesions::React	NextJS + Astro	NextJS to Astro: more control = faster sites - YouTube	
PHP~2a$F~o	Basic-66869	Interview Quesions::React	useEffect called twice in react 18	amazing features that Identifying unsafe lifecycles => we shouldn't disable it	
Tm9i!mbr$?	Basic-66869	Interview Quesions::JavaScript	What is the Document Object Model (DOM)?	The Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects, where each object corresponds to a part of the document (e.g., elements, attributes, text). The DOM allows developers to access and manipulate the content, structure, and style of a web page using JavaScript.	
=C10XTq[%+	Basic-66869	Interview Quesions::JavaScript	How do you add an event listener to an element?	To add an event listener on an element, you have to first “get” that element through one of the many methods of the document object (i.e. getElementById, etc) and then use the addEventListener method of the obtained object.\n\nThe method will receive the event name (i.e. ‘click’, ‘keyup’, ‘mouseup’, etc), the event handler function and, optionally, a boolean indicating whether the event should be captured during the capturing phase.	
1VAu-op2HU	Basic-66869	Interview Quesions::JavaScript	What is the difference between null and undefined?	In JavaScript, “undefined” is the default value new variables take, and it means the variable has been defined but it hasn’t been assigned any value just yet.\n\nAnd “null” is actually a value that signals “no value” or “no object”, it is specifically assigned to the variable by the developer.	
d>3F?Xx3:1	Basic-66869	Interview Quesions::JavaScript	What is the difference between cookies, sessionStorage, and localStorage?		
5Bv7_9IB[3	Basic-66869	Interview Quesions::JavaScript	How does the browser render a website?		
M^wUK1Tr?l	Basic-66869	Interview Quesions::JavaScript	What are closures, and how/why would you use them?		
xIt4%CGGz8	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain why the following doesn't work as an IIFE: function foo(){ }();. What needs to be changed to properly make it an IIFE?	IIFE stands for Immediately Invoked Function Expressions. The JavaScript parser reads function foo(){ }(); as function foo(){ } and ();, where the former is a function declaration and the latter (a pair of parentheses) is an attempt at calling a function but there is no name specified, hence it throws Uncaught SyntaxError: Unexpected token ).Here are two ways to fix it that involves adding more parentheses: (function foo(){ })() and (function foo(){ }()). Statements that begin with function are considered to be function declarations; by wrapping this function within (), it becomes a function expression which can then be executed with the subsequent (). These functions are not exposed in the global scope and you can even omit its name if you do not need to reference itself within the body.You might also use void operator: void function foo(){ }();. Unfortunately, there is one issue with such approach. The evaluation of given expression is always undefined, so if your IIFE function returns anything, you can't use it. An example:// Don't add JS syntax to this code block to prevent Prettier from formatting it. const foo = void function bar() { return 'foo'; }(); console.log(foo); // undefined Referenceshttp://lucybain.com/blog/2014/immediately-invoked-function-expression/https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void	
lSIl-tvZ<*	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain how this works in JavaScript	Basically, the value of this depends on how the function is called.The following rules are applied:If the new keyword is used when calling the function, this inside the function is a brand new object.If apply, call, or bind are used to call/create a function, this inside the function is the object that is passed in as the argument.If a function is called as a method, such as obj.method() — this is the object that the function is a property of.If a function is invoked without any of the conditions present above, this is the global object. In a browser, it is the window object. If in strict mode ('use strict'), this will be undefined instead of the global object.If multiple of the above rules apply, the rule that is higher wins and will set the this value.If the function is an ES2015 arrow function, it ignores all the rules above and receives the this value of its surrounding scope at the time it is created.For an in-depth explanation, do check out his article on Medium.Can you give an example of one of the ways that working with this has changed in ES6?ES6 allows you to use arrow functions which uses the enclosing lexical scope. This is usually convenient, but does prevent the caller from controlling context via .call or .apply—the consequences being that a library such as jQuery will not properly bind this in your event handler functions. Thus, it's important to keep this in mind when refactoring large legacy applications.Referenceshttps://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3https://stackoverflow.com/a/3127440/1751946	
sSRksn3Lj>	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain how prototypal inheritance works	"All JavaScript objects have a prototype property, that is a reference to another object. When a property is accessed on an object and if the property is not found on that object, the JavaScript engine looks at the object's prototype, and the prototype's prototype and so on, until it finds the property defined on one of the prototypes or until it reaches the end of the prototype chain. This behavior simulates classical inheritance, but it is really more of delegation than inheritance.Example of Prototypal InheritanceWe already have a build-in Object.create, but if you were to provide a polyfill for it, that might look like:if (typeof Object.create !== 'function') { Object.create = function (parent) { function Tmp() {} Tmp.prototype = parent; return new Tmp(); }; } const Parent = function() { this.name = ""Parent""; } Parent.prototype.greet = function() { console.log(""hello from Parent""); } const child = Object.create(Parent.prototype); child.cry = function() { console.log(""waaaaaahhhh!""); } child.cry(); // Outputs: waaaaaahhhh! child.greet(); // Outputs: hello from ParentThings to note are:.greet is not defined on the child, so the engine goes up the prototype chain and finds .greet off the inherited from Parent.We need to call Object.create in one of following ways for the prototype methods to be inherited:Object.create(Parent.prototype);Object.create(new Parent(null));Object.create(objLiteral);Currently, child.constructor is pointing to the Parent:child.constructor ƒ () { this.name = ""Parent""; } child.constructor.name ""Parent""If we'd like to correct this, one option would be to do:function Child() { Parent.call(this); this.name = 'child'; } Child.prototype = Parent.prototype; Child.prototype.constructor = Child; const c = new Child(); c.cry(); // Outputs: waaaaaahhhh! c.greet(); // Outputs: hello from Parent c.constructor.name; // Outputs: ""Child""Referenceshttps://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpsonhttps://davidwalsh.name/javascript-objectshttps://crockford.com/javascript/prototypal.htmlhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain"	
uxIl-AwVOe	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between a variable that is: null, undefined or undeclared? How would you go about checking for any of these states?	Undeclared variables are created when you assign a value to an identifier that is not previously created using var, let or const. Undeclared variables will be defined globally, outside of the current scope. In strict mode, a ReferenceError will be thrown when you try to assign to an undeclared variable. Undeclared variables are bad just like how global variables are bad. Avoid them at all cost! To check for them, wrap its usage in a try/catch block.function foo() { x = 1; // Throws a ReferenceError in strict mode } foo(); console.log(x); // 1A variable that is undefined is a variable that has been declared, but not assigned a value. It is of type undefined. If a function does not return any value as the result of executing it is assigned to a variable, the variable also has the value of undefined. To check for it, compare using the strict equality (===) operator or typeof which will give the 'undefined' string. Note that you should not be using the abstract equality operator to check, as it will also return true if the value is null.var foo; console.log(foo); // undefined console.log(foo === undefined); // true console.log(typeof foo === 'undefined'); // true console.log(foo == null); // true. Wrong, don't use this to check! function bar() {} var baz = bar(); console.log(baz); // undefinedA variable that is null will have been explicitly assigned to the null value. It represents no value and is different from undefined in the sense that it has been explicitly assigned. To check for null, simply compare using the strict equality operator. Note that like the above, you should not be using the abstract equality operator (==) to check, as it will also return true if the value is undefined.var foo = null; console.log(foo === null); // true console.log(typeof foo === 'object'); // true console.log(foo == undefined); // true. Wrong, don't use this to check!As a personal habit, I never leave my variables undeclared or unassigned. I will explicitly assign null to them after declaring if I don't intend to use it yet. If you use a linter in your workflow, it will usually also be able to check that you are not referencing undeclared variables.Referenceshttps://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variableshttps://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined	
B#B(?XiGcl	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is a closure, and how/why would you use one?	Closures - JavaScript | MDN (mozilla.org) a closure gives you access to an outer function's scope from an inner function. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was createdThe closure has three scope chains:1. Own scope where variables defined between its curly brackets2. Outer functions' variables3. Global variables Why would you use one?Data privacy / emulating private methods with closures. Commonly used in the module pattern.Partial applications or currying function: a function that takes a function with multiple parameters and returns a function with fewer parameters	
L3n$_#_Xnp	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Can you describe the main difference between a .forEach loop and a .map() loop and why you would pick one versus the other?	"To understand the differences between the two, let's look at what each function does.forEachIterates through the elements in an array.Executes a callback for each element.Does not return a value.const a = [1, 2, 3]; const doubled = a.forEach((num, index) => { // Do something with num and/or index. }); // doubled = undefinedmapIterates through the elements in an array.""Maps"" each element to a new element by calling the function on each element, creating a new array as a result.const a = [1, 2, 3]; const doubled = a.map(num => { return num \* 2; }); // doubled = [2, 4, 6]The main difference between .forEach and .map() is that .map() returns a new array. If you need the result, but do not wish to mutate the original array, .map() is the clear choice. If you simply need to iterate over an array, forEach is a fine choice."	
j&fIguVlLP	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between host objects and native objects?	Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as String, Math, RegExp, Object, Function, etc.Host objects are provided by the runtime environment (browser or Node), such as window, XMLHTTPRequest, etc.	
u$0(Ek&Zf2	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What's the difference between .bind, .call and .apply?	Both .call and .apply are used to invoke functions and the first parameter will be used as the value of thiswithin the function. However, .call takes in comma-separated arguments as the next arguments while .applytakes in an array of arguments as the next argument. An easy way to remember this is C for call and comma-separated and A for apply and an array of arguments.function add(a, b) { return a + b; } console.log(add.call(null, 1, 2)); // 3 console.log(add.apply(null, [1, 2])); // 3 const Temp = function() { this.c = 1; } Temp.prototype.add = function (a,b) { return (this.c || 0) + a + b; } const temp = new Temp(); console.log(temp.add(1,2)); // 4 console.log(temp.add.call({ c:2 }, 1, 2)); // 5 console.log(temp.add.apply({ c:3 }, [1, 2])); // 6 const bindFunc = temp.add.bind({ c: 4 }); console.log(bindFunc(1,2)); // 7	
d=D4Joc)~F	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain Function.prototype.bind.	Taken word-for-word from MDN:The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.In my experience, it is most useful for binding the value of this in methods of classes that you want to pass into other functions. This is frequently done in React components.	
P_L+L6Fx^f	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Have you ever used JavaScript templating? If so, what libraries have you used?	Yes. Handlebars, Underscore, Lodash, AngularJS, and JSX. I disliked templating in AngularJS because it made heavy use of strings in the directives and typos would go uncaught. JSX is my new favorite as it is closer to JavaScript and there is barely any syntax to learn. Nowadays, you can even use ES2015 template string literals as a quick way for creating templates without relying on third-party code.const template = `<div>My name is: ${name}</div>`;However, do be aware of a potential XSS in the above approach as the contents are not escaped for you, unlike in templating libraries.	
NO?|xWO8/f	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	"Explain ""hoisting""."	Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation.	
OvAxocDxWd	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Describe event bubbling.	When an event triggers on a DOM element, it will attempt to handle the event if there is a listener attached, then the event is bubbled up to its parent and the same thing happens. This bubbling occurs up the element's ancestors all the way to the document. Event bubbling is the mechanism behind event delegation.	
t#z{vItZ[o	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	"What's the difference between an ""attribute"" and a ""property""?"	"Attributes are defined on the HTML markup but properties are defined on the DOM. To illustrate the difference, imagine we have this text field in our HTML: <input type=""text"" value=""Hello"">.const input = document.querySelector('input'); console.log(input.getAttribute('value')); // Hello console.log(input.value); // HelloBut after you change the value of the text field by adding ""World!"" to it, this becomes:console.log(input.getAttribute('value')); // Hello console.log(input.value); // Hello World!"	
GPr)]um6Aa	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is the difference between == and ===?	== is the abstract equality operator while === is the strict equality operator. The == operator will compare for equality after doing any necessary type conversions. The === operator will not do type conversion, so if two values are not the same type === will simply return false. When using ==, funky things can happen, such as:1 == '1'; // true 1 == [1]; // true 1 == true; // true 0 == ''; // true 0 == '0'; // true 0 == false; // trueMy advice is never to use the == operator, except for convenience when comparing against null or undefined, where a == null will return true if a is null or undefined.var a = null; console.log(a == null); // true console.log(a == undefined); // true	
Di;q&0JI2e	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?	Every script has access to the global scope, and if everyone uses the global scope to define their variables, collisions will likely occur	
QR/fx-@j4R	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain what a single page app is and how to make one SEO-friendly.	"Web developers these days refer to the products they build as web apps, rather than websites. While there is no strict difference between the two terms, web apps tend to be highly interactive and dynamic, allowing the user to perform actions and receive a response to their action. Traditionally, the browser receives HTML from the server and renders it. When the user navigates to another URL, a full-page refresh is required and the server sends fresh new HTML to the new page. This is called server-side rendering.However, in modern SPAs, client-side rendering is used instead. The browser loads the initial page from the server, along with the scripts (frameworks, libraries, app code) and stylesheets required for the whole app. When the user navigates to other pages, a page refresh is not triggered. The URL of the page is updated via the HTML5 History API. New data required for the new page, usually in JSON format, is retrieved by the browser via AJAX requests to the server. The SPA then dynamically updates the page with the data via JavaScript, which it has already downloaded in the initial page load. This model is similar to how native mobile apps work.The benefits:The app feels more responsive and users do not see the flash between page navigations due to full-page refreshes.Fewer HTTP requests are made to the server, as the same assets do not have to be downloaded again for each page load.Clear separation of the concerns between the client and the server; you can easily build new clients for different platforms (e.g. mobile, chatbots, smart watches) without having to modify the server code. You can also modify the technology stack on the client and server independently, as long as the API contract is not broken.The downsides:Heavier initial page load due to the loading of framework, app code, and assets required for multiple pages.There's an additional step to be done on your server which is to configure it to route all requests to a single entry point and allow client-side routing to take over from there.SPAs are reliant on JavaScript to render content, but not all search engines execute JavaScript during crawling, and they may see empty content on your page. This inadvertently hurts the Search Engine Optimization (SEO) of your app. However, most of the time, when you are building apps, SEO is not the most important factor, as not all the content needs to be indexable by search engines. To overcome this, you can either server-side render your app or use services such as Prerender to ""render your javascript in a browser, save the static HTML, and return that to the crawlers""."	
Gro(j1-0.P	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What are the pros and cons of using Promises instead of callbacks?	ProsAvoid callback hell which can be unreadable.Makes it easy to write sequential asynchronous code that is readable with .then().Makes it easy to write parallel asynchronous code with Promise.all().With promises, these scenarios which are present in callbacks-only coding, will not happen:Call the callback too earlyCall the callback too late (or never)Call the callback too few or too many timesFail to pass along any necessary environment/parametersSwallow any errors/exceptions that may happenConsSlightly more complex code (debatable).In older browsers where ES2015 is not supported, you need to load a polyfill in order to use it.	
f4B<J6Zi=J	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is Promises?	A promise is an object that may produce a single value sometime in the future: either a resolved value or a reason that it's not resolved (e.g., a network error occurred). A promise may be in one of 3 possible states: fulfilled, rejected, or pending. Promise users can attach callbacks to handle the fulfilled value or the reason for rejection. As the Promise.prototype.then() and Promise.prototype.catch() methods return promises, they can be chained.	
xOaFh|/qlF	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What tools and techniques do you use for debugging JavaScript code?	React and ReduxReact DevtoolsRedux DevtoolsVueVue DevtoolsJavaScriptChrome Devtoolsdebugger statementGood old console.log debugging	
h[x>(Ez0c~	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain the difference between mutable and immutable objects.	"Immutability is a core principle in functional programming, and has lots to offer to object-oriented programs as well. A mutable object is an object whose state can be modified after it is created. An immutable object is an object whose state cannot be modified after it is created.What is an example of an immutable object in JavaScript?In JavaScript, some built-in types (numbers, strings) are immutable, but custom objects are generally mutable.Some built-in immutable JavaScript objects are Math, Date.Here are a few ways to add/simulate immutability on plain JavaScript objects.Object Constant PropertiesBy combining writable: false and configurable: false, you can essentially create a constant (cannot be changed, redefined or deleted) as an object property, like:let myObject = {}; Object.defineProperty(myObject, 'number', { value: 42, writable: false, configurable: false, }); console.log(myObject.number); // 42 myObject.number = 43; console.log(myObject.number); // 42Prevent ExtensionsIf you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call Object.preventExtensions(...):var myObject = { a: 2 }; Object.preventExtensions(myObject); myObject.b = 3; myObject.b; // undefined In non-strict mode, the creation of b fails silently. In strict mode, it throws a TypeError.SealObject.seal() creates a ""sealed"" object, which means it takes an existing object and essentially calls Object.preventExtensions() on it, but also marks all its existing properties as configurable: false.So, not only can you not add any more properties, but you also cannot reconfigure or delete any existing properties (though you can still modify their values).FreezeObject.freeze() creates a frozen object, which means it takes an existing object and essentially calls Object.seal() on it, but it also marks all ""data accessor"" properties as writable:false, so that their values cannot be changed.This approach is the highest level of immutability that you can attain for an object itself, as it prevents any changes to the object or to any of its direct properties (though, as mentioned above, the contents of any referenced other objects are unaffected).var immutable = Object.freeze({});Freezing an object does not allow new properties to be added to an object and prevents from removing or altering the existing properties. Object.freeze() preserves the enumerability, configurability, writability and the prototype of the object. It returns the passed object and does not create a frozen copy."	
nVy)4CLX9l	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	Explain the difference between synchronous and asynchronous functions.	Synchronous functions are blocking while asynchronous functions are not. In synchronous functions, statements complete before the next statement is run. In this case, the program is evaluated exactly in order of the statements and execution of the program is paused if one of the statements take a very long time.Asynchronous functions usually accept a callback as a parameter and execution continue on the next line immediately after the asynchronous function is invoked. The callback is only invoked when the asynchronous operation is complete and the call stack is empty. Heavy duty operations such as loading data from a web server or querying a database should be done asynchronously so that the main thread can continue executing other operations instead of blocking until that long operation to complete (in the case of browsers, the UI will freeze).	
P-jr#X^8>.	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What is event loop? What is the difference between call stack and task queue?	The event loop is a single-threaded loop that monitors the call stack and checks if there is any work to be done in the task queue. If the call stack is empty and there are callback functions in the task queue, a function is dequeued and pushed onto the call stack to be executed. Whenever functions like setTimeout, http.get, and fs.readFile are called, Node.js executed the event loop and then proceeds with the further code without waiting for the output. Call Stack is a data structure for javascript interpreters to keep track of function calls in the program. It has two major actions. - Whenever you call a function for its execution, you are pushing it to the stack.- Whenever the execution is completed, the function is popped out of the stack.	
pTgUpHtFDS	Basic (and reversed card)-1cc8b	Interview Quesions::JavaScript	What are the differences between variables created using let, var or const?	"Variables declared using the var keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. let and const are block scoped, meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).function foo() { // All variables are accessible within functions. var bar = 'bar'; let baz = 'baz'; const qux = 'qux'; console.log(bar); // bar console.log(baz); // baz console.log(qux); // qux } console.log(bar); // ReferenceError: bar is not defined console.log(baz); // ReferenceError: baz is not defined console.log(qux); // ReferenceError: qux is not definedif (true) { var bar = 'bar'; let baz = 'baz'; const qux = 'qux'; } // var declared variables are accessible anywhere in the function scope. console.log(bar); // bar // let and const defined variables are not accessible outside of the block they were defined in. console.log(baz); // ReferenceError: baz is not defined console.log(qux); // ReferenceError: qux is not definedvar allows variables to be hoisted, meaning they can be referenced in code before they are declared. let and const will not allow this, instead throwing an error.console.log(foo); // undefined var foo = 'foo'; console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization let baz = 'baz'; console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization const bar = 'bar';Redeclaring a variable with var will not throw an error, but 'let' and 'const' will.var foo = 'foo'; var foo = 'bar'; console.log(foo); // ""bar"" let baz = 'baz'; let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declaredlet and const differ in that let allows reassigning the variable's value while const does not.// This is fine. let foo = 'foo'; foo = 'bar'; // This causes an exception. const baz = 'baz'; baz = 'qux';"	
l`fNWr-H@K	Basic-66869	Interview Quesions::JavaScript	JavaScript (ES5) vs ES6	"JavaScript is the programming language, while ES6 (ECMAScript 2015) is a specific version of the ECMAScript standard that JavaScript implements. ECMAScript is the specification that defines the core features and syntax of the JavaScript language. The key differences between ""JavaScript"" (referring to older versions or the general concept of the language) and ES6 are primarily in the features and syntax introduced in ES6: Variable Declarations: ES6 introduced let and const for block-scoped variable declarations, addressing issues with var's function-scoping and hoisting behavior. Arrow Functions: A concise syntax for writing functions, especially useful for anonymous functions and maintaining this context. Classes: Syntactic sugar for creating constructor functions and managing inheritance, making object-oriented programming in JavaScript more intuitive. Template Literals: String literals allowing embedded expressions and multi-line strings using backticks (` `` `). Destructuring Assignment: A convenient way to extract values from arrays or properties from objects into distinct variables. Spread and Rest Operators: The spread operator (...) expands iterables (like arrays or strings) into individual elements, while the rest operator collects multiple arguments into an array. Modules (Import/Export): A standardized way to organize and reuse code across different files, providing better modularity than older methods like CommonJS. Promises: A built-in mechanism for handling asynchronous operations, improving upon callback-based patterns. Default Parameters: Allows functions to have default values for parameters if no value is provided during the function call. Backward Compatibility: ES6 is largely backward compatible with previous versions of JavaScript (like ES5). This means that most code written in ES5 will still function correctly in an environment that supports ES6. In essence, ES6 significantly enhanced JavaScript by introducing modern syntax, improved features for handling asynchronous operations, better variable scoping, and more organized code structures. While older JavaScript code still runs, ES6 provides more powerful and readable ways to write JavaScript."	
F#r]86%E*(	Basic-66869	Interview Quesions::JavaScript	What is the Temporal Dead Zone	The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable with the let and const keywords, but not with var. The time span between the creation of a variable’s binding and its declaration, is called the temporal dead zone.	
A9v{;c}-dj	Basic-66869	Interview Quesions::JavaScript	What is heap	Heap(Or memory heap) is the memory location where objects are stored when we define variables.	
mckQna;YlZ	Basic-66869	Interview Quesions::JavaScript	What is a microTask queue	Microtask Queue is the new queue where all the tasks initiated by promise objects get processed before the callback queue.	
go^E&z*,T9	Basic-66869	Interview Quesions::JavaScript	What is babel	Babel is a JavaScript transpiler to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments	
nZqel6X)2V	Basic-66869	Interview Quesions::JavaScript	What is the difference between Function constructor (new Function) and function declaration	The functions which are created with Function constructor do not create closures to their creation contexts but they are always created in the global scope. i.e, the function can access its own local variables and global scope variables only. Whereas function declarations can access outer function variables(closures)	
G~0z.k{&dh	Basic-66869	Interview Quesions::JavaScript	What is the difference between function and class declaration	The main difference between function declarations and class declarations is hoisting. The function declarations are hoisted but not class declarations.	
i]I,Q{rAlj	Basic-66869	Interview Quesions::JavaScript	What are the different kinds of generators	There are five kinds of generators, Generator function declaration: function* myGenFunc() { yield 1; yield 2; yield 3; } const genObj = myGenFunc(); Generator function expressions: const myGenFunc = function* () { yield 1; yield 2; yield 3; }; const genObj = myGenFunc(); Generator method definitions in object literals: const myObj = { _ myGeneratorMethod() { yield 1; yield 2; yield 3; } }; const genObj = myObj.myGeneratorMethod(); Generator method definitions in class: class MyClass { _ myGeneratorMethod() { yield 1; yield 2; yield 3; } } const myObject = new MyClass(); const genObj = myObject.myGeneratorMethod(); Generator as a computed property: const SomeObj = { \*[Symbol.iterator] () { yield 1; yield 2; yield 3; } } console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]	
s<_},]>oRd	Basic-66869	Interview Quesions::JavaScript	What is the difference between setTimeout, setImmediate and process.nextTick?	Set Timeout: setTimeout() is to schedule execution of a one-time callback after delay milliseconds.Set Immediate: The setImmediate function is used to execute a function right before the current event loop finishes.Process NextTick: If process.nextTick() is called in a given phase, all the callbacks passed to process.nextTick() will be resolved before the event loop continues. This will block the event loop and create I/O Starvation if process.nextTick() is called recursively.	
OT)=[.-|$s	Basic-66869	Interview Quesions::JavaScript	debounce vs throttle	The major difference between debouncing and throttling is that debounce calls a function when a user hasn't carried out an event in a specific amount of time, while throttle calls a function at intervals of a specified amount of time while the user is carrying out an event.	
j<cP[%<ZSO	Basic-66869	Interview Quesions::JavaScript	"""1"" + true - ""1"""	"= NaN ""1"" + true = ""1true"" ""1true"" - ""1"" = NaN"	
idh*]GpS!<	Basic-66869	Interview Quesions::JavaScript	"const a = ""abc"" a[2] = ""d"" console.log(a);"	"""abc"" -> String is immutable"	
jUcLeHGnnA	Basic-66869	Interview Quesions::JavaScript	const obj = { name: 'Quang', // showName: function () {} showName(age) { // method console.log(`123 ${this.name} ${age}`); } } const showName = obj.showName; showName();	//123 undefined => because this is a regular function, not a method -> this keyword point to undefined // solutions showName.call(person, 23); // Anna 23 // -> call the showName method with this keyword set to person showName.apply(person, [23]); // do the same thing as call method	
is?vWdm;EP	Basic-66869	Interview Quesions::JavaScript	Arrow function vs function declaration. Give Example	The Difference Between Regular Functions and Arrow Functions | by Ashutosh Verma | Better Programming - Different syntax - Arrow functions do not have an arguments binding. - Arrow functions do not have their own this - Regular functions created using function declarations or expressions are constructible. Hence, they can be called using the new keyword. Whereas, the arrow functions are only callable and not constructible and cannot use the new keyword - No duplicate named parameters	
Ncgx-}+!hR	Basic-66869	Interview Quesions::JavaScript	Bubbling and Capturing	"Bubbling and capturing (javascript.info) Bubbling and capturing describe the two phases of event propagation in the DOM when an event occurs on an element with ancestors. Bubbling (default): The event starts at the target element and then ""bubbles"" upwards through its parent elements in the DOM hierarchy, triggering event listeners attached to those ancestors along the way. Capturing: The event starts at the root of the DOM and ""captures"" downwards through the ancestors to the target element, triggering event listeners attached to those ancestors before reaching the target. Capturing is enabled by passing true as the third argument to addEventListener(). Both phases contribute to the event flow, allowing for flexible event handling and techniques like event delegation. Capturing happens before bubbling in Event Propagation If event.stopPropagation() is called during the capturing phase, then the event travel stops, no bubbling will occur. Non-bubbling events such as focus, blur, load can be handled by Capturing"	
mQQ}XK2yh$	Basic-66869	Interview Quesions::JavaScript	[Array] iterative methods and empty slots	"iterative methods: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#iterative_methods iterative methods behave differently with empty slots sparse arrays: Arrays can contain ""empty slots"" -> Array methods and empty slots: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array_methods_and_empty_slots"	
c3{N:m-cw/	Basic-66869	Interview Quesions::JavaScript	CommonJS vs ESM	CommonJS (CJS) uses synchronous require() and module.exports syntax, designed for Node.js, while ECMAScript Modules (ESM) use asynchronous import and export syntax, serving as the official JavaScript standard and supporting native browser environments and Node.js. The main distinctions are their syntax, synchronous vs. asynchronous module loading, and compatibility with different environments. ESM is the future standard, offering benefits like tree shaking and better performance, while CommonJS is still prevalent in the existing Node.js ecosystem. CommonJS (CJS) Syntax: Uses require() to import modules and module.exports to export them. Loading: Loads modules synchronously, which can block execution until the module is loaded. Environment: Primarily used in Node.js. Characteristics: Has been the long-standing standard for server-side JavaScript in Node.js. Provides Node-specific variables like **dirname and **filename. ECMAScript Modules (ESM) Syntax: Uses import and export keywords for module management. Loading: Supports asynchronous loading, enabling better parallelism. Environment: Natively supported in modern web browsers and modern Node.js environments. Characteristics: The official, standardized module system for JavaScript. Enables static analysis of dependencies, leading to more efficient tree shaking (dead code elimination). More suitable for modern web applications due to native browser support and performance benefits. Key Differences at a Glance Feature CommonJS (CJS) ECMAScript Modules (ESM) Syntax require() and module.exports import and export Loading Synchronous Asynchronous Standard De facto standard for Node.js Official JavaScript standard Browser Support Not native Native When to Use Which Use CommonJS for: Older Node.js projects or environments where it's the established standard and you prioritize simplicity. Use ESM for: Modern web applications, new Node.js projects, and situations where you need better performance, native browser support, and advanced features like tree shaking.	
E>Br&4AKXa	Basic-66869	Interview Quesions::JavaScript	var vs let vs const	"In JavaScript, var, let, and const are keywords used to declare variables, each with distinct characteristics regarding scope, reassignment, and hoisting. 1. Scope: var: Variables declared with var have function scope or global scope. This means they are accessible throughout the entire function in which they are declared, or globally if declared outside any function.let: Variables declared with let have block scope. They are only accessible within the specific block (e.g., if statements, for loops, or any curly braces {}) where they are defined.const: Similar to let, const also provides block scope. 2. Reassignment: var: Variables declared with var can be reassigned and redeclared within the same scope. let: Variables declared with let can be reassigned, but they cannot be redeclared within the same block scope. const: Variables declared with const cannot be reassigned after their initial assignment. They are used to declare constants or read-only references. However, if a const variable holds an object or array, its properties or elements can be modified, but the variable itself cannot be pointed to a different object or array. 3. Hoisting: var: Variables declared with var are hoisted to the top of their function or global scope. This means they can be accessed before their declaration, though their value will be undefined until the actual assignment. let and const: Variables declared with let and const are also hoisted, but they are subject to the ""Temporal Dead Zone"" (TDZ). This means accessing them before their declaration will result in a ReferenceError. In summary: Use const for values that should not change throughout the program's execution.Use let for variables whose values might need to be reassigned later in the code.Avoid using var in modern JavaScript development due to its less predictable scoping behavior, which can lead to unexpected bugs. let and const offer more controlled and intuitive variable declaration."	
Os!i<T1O?9	Basic-66869	Interview Quesions::NodeJS	What is Node.js? / How does Node.js work?	Node.js is an open-source server side runtime environment built on Chrome's V8 JavaScript engine. It provides an event driven, non-blocking (asynchronous) I/O and cross-platform runtime environment for building server-side applications using JavaScript.	
n==/`?wf|k	Basic-66869	Interview Quesions::NodeJS	What is Node.js Single Process Model?	Node.js runs in a single process and the application code runs in a single thread and thereby needs less resources than other platforms. This single thread doesn't have to wait for the request to complete and is free to handle the next request.	
F|xw,Dj$}*	Basic-66869	Interview Quesions::NodeJS	What are the data types in Node.js?	Just like JS, there are two categories of data types in Node: Primitives and Objects. PrimitivesStringNumberBigintBooleanUndefinedNullSymbol Objects Function Array Buffer: Node.js includes an additional data type called Buffer (not available in browser's JavaScript). Buffer is mainly used to store binary data, while reading from a file or receiving packets over the network. Buffer is a class. other regular objects	
O$6KfOi?mb	Basic-66869	Interview Quesions::NodeJS	How to create a simple server in Node.js that returns Hello World?	Step 01: Create a project directory mkdir myapp cd myapp Step 02: Initialize project and link it to npm npm init This creates a package.json file in your myapp folder. The file contains references for all npm packages you have downloaded to your project. The command will prompt you to enter a number of things. You can enter your way through all of them EXCEPT this one: entry point: (index.js) Rename this to: app.js Step 03: Install Express in the myapp directory npm install express --save Step 04: app.js var express = require('express'); var app = express(); app.get('/', function (req, res) { res.send('Hello World!'); }); app.listen(3000, function () { console.log('Example app listening on port 3000!'); }); Step 05: Run the app node app.js	
bOVw[uO?5`	Basic-66869	Interview Quesions::NodeJS	What does the runtime environment mean in Node.js?	The Node.js runtime is the software stack responsible for installing your web service's code and its dependencies and running your service. The runtime environment is literally just the environment your application is running in. This can be used to describe both the hardware and the software that is running your application. How much RAM, what version of node, what operating system, how much CPU cores, can all be referenced when talking about a runtime environment.	
kDoIQ1/>X,	Basic-66869	Interview Quesions::NodeJS	Explain usage of NODE_ENV?	NODE_ENV is an environment variable made popular by the express web server framework. When a node application is run, it can check the value of the environment variable and do different things based on the value.	
IOJrD=O3%#	Basic-66869	Interview Quesions::NodeJS	What are the core modules of Node.js?	They are defined within the Node.js source and are located in the lib/ folder, and Node.js has several modules compiled into the binary such as fs, os, path, util, http	
q45q2r`Kir	Basic-66869	Interview Quesions::NodeJS	What is callback function in Node.js?	In node.js, we basically use callbacks for handling asynchronous operations like — making any I/O request, database operations or calling an API to fetch some data. Callback allows our code to not get blocked when a process is taking a long time.	
ufeuyTT.qs	Basic-66869	Interview Quesions::NodeJS	How assert works in Node.js?	In Node.js, assert is used to write tests. It only provides feedback only when any of the running test cases fails. This module was built to be used internally by Node.js.	
P@l8LiU[Y3	Basic-66869	Interview Quesions::NodeJS	What is an error-first callback?	"fs.readFile( ""file.json"", function ( err, data ) { if ( err ) { console.error( err ); } console.log( data ); }); Error-first callbacks in Node.js are used to pass errors and data. The very first parameter you need to pass to these functions has to be an error object while the other parameters represent the associated data. Thus you can pass the error object for checking if anything is wrong and handle it. In case there is no issue, you can just go ahead and with the subsequent arguments."	
QTRuLUy^0O	Basic-66869	Interview Quesions::NodeJS	List down the major benefits of using Node.js?		
LGZq=`VN|4	Basic-66869	Interview Quesions::NodeJS	What is package.json?	The package.json file in Node.js is the heart of the entire application. It is basically the manifest file that contains the metadata of the project where we define the properties of a package.	
sdl{VQt)i~	Basic-66869	Interview Quesions::NodeJS	What do you understand by Event-driven programming?	That means instead of waiting for a response javascript will keep executing while listening for other events.	
vefp?mfIG*	Basic-66869	Interview Quesions::NodeJS	What is an Event loop in Node.js and how does it work?	"The Node.js event loop is a core mechanism that allows it to handle asynchronous operations efficiently using a single thread, enabling non-blocking I/O. Instead of waiting for a task to finish, Node.js offloads it to the system kernel (via the libuv library) and continues with the rest of its code. When the task is complete, its callback is placed in a queue to be executed by the event loop. Core componentsCall Stack: A last-in, first-out (LIFO) stack that keeps track of the functions currently being executed. When synchronous code runs, functions are pushed onto the stack and popped off when they are completed.libuv: A C++ library that gives Node.js access to the underlying operating system and manages asynchronous tasks like file system operations, networking, and timers in the background.Callback Queues: Where asynchronous operation callbacks are placed once their associated task has completed. There are different queues for different types of callbacks.Microtask Queue: A high-priority queue that holds callbacks for Promise.then(), Promise.catch(), Promise.finally(), queueMicrotask(), and process.nextTick().Event Loop: A continuous process that checks if the call stack is empty. If it is, the event loop takes callbacks from the queues and pushes them onto the call stack for execution, in a specific order. Event loop phases and their order The event loop cycles continuously through several phases, executing callbacks from each phase's queue before moving to the next. After each phase, it processes the microtask queues completely before moving on. Timers: This phase executes setTimeout() and setInterval() callbacks whose specified time has elapsed.Pending Callbacks: This phase executes certain system-related callbacks, like deferred I/O callbacks from the previous loop iteration.Idle, Prepare: This is an internal phase used for housekeeping by libuv.Poll: This is the most important phase for processing I/O events.It retrieves new I/O events and executes their callbacks.If the poll queue is empty, the loop will either wait for new events or move to the next phase if setImmediate() callbacks are scheduled.Check: This phase executes all setImmediate() callbacks.Close Callbacks: This phase handles callbacks for closing handles, such as socket.on('close'). How microtasks are prioritized Microtasks have a higher priority than the callbacks in the main event loop phases. This ensures that promises and process.nextTick() are executed as quickly as possible. The high-level flow is: Execute all synchronous code in the call stack.Process all items in the microtask queues (process.nextTick() and Promises).Move to the first phase of the event loop (Timers).Execute all callbacks in the Timers queue.After clearing the Timers queue, process the microtask queues again.Move to the next phase (Pending Callbacks).Repeat this process until all phases and queues are empty. Example walkthrough javascript console.log('Start'); setTimeout(() => { console.log('setTimeout'); }, 0); Promise.resolve().then(() => { console.log('Promise'); }); setImmediate(() => { console.log('setImmediate'); }); console.log('End'); Use code with caution. Output:Start: Synchronous code is executed immediately.End: Synchronous code is executed immediately.Promise: The microtask queue is drained completely after the initial synchronous code finishes.setTimeout: The event loop moves to the ""timers"" phase and runs the setTimeout callback.setImmediate: The event loop moves to the ""check"" phase and runs the setImmediate callback. Note: While setTimeout(fn, 0) is a timer, the setImmediate() callback is specifically designed to execute in the ""check"" phase. In many cases, the exact order between setTimeout(fn, 0) and setImmediate() can be non-deterministic, but setImmediate will always run after the Poll phase, while setTimeout runs in the Timers phase."	
Q`~d`4(wBr	Basic-66869	Interview Quesions::NodeJS	Explain REPL in the context of Node.js.	REPL in Node.js stands for Read, Eval, Print, and Loop. It represents a computer environment such as a window console or Unix/Linux shell where any command can be entered and then the system can respond with an output. Node.js comes bundled with a REPL environment by default. REPL can perform the below-listed tasks:Read: Reads the user’s input, parses it into JavaScript data-structure and then stores it in the memory.Eval: Receives and evaluates the data structure.Print: Prints the final result.Loop: Loops the provided command until CTRL+C is pressed twice.	
O8t&HxGM3m	Basic-66869	Interview Quesions::NodeJS	What is module in Node.js?	Modules refer to small units of independent, reusable code. It is used to encapsulate all the related codes or functions into a single file.	
dhvn/6eO_k	Basic-66869	Interview Quesions::NodeJS	Explain libuv.	Libuv is a multi-platform support library of Node.js which majorly is used for asynchronous I/O. A few of the important features of libuv are event loop, Asynchronous file & network operations. FYI, it also supports to handle the child processes	
o66NWX}9(8	Basic-66869	Interview Quesions::NodeJS	Explain the purpose of ExpressJS package?	Express.js is a framework built on top of Node.js that facilitates the management of the flow of data between server and routes in the server-side applications. Express.js is developed on the middleware module of Node.js called connect. The connect module further makes use of http module to communicate with Node.js.	
v~cVm*8B`d	Basic-66869	Interview Quesions::NodeJS	Differentiate between process.nextTick() and setImmediate()?	Same: both are functions of the Timers module which help in executing the code after a predefined period of time. Diff: setImmediate – Used to execute code at the end of the current event loop cycleprocess.nextTick – Used to schedule a callback function that needs to be invoked in the next iteration of the Event Loop	
GD*SDh?Cn4	Basic-66869	Interview Quesions::NodeJS	How does Node.js handle the child threads?	In general, Node.js is a single threaded process and doesn’t expose the child threads or thread management methods. But you can still make use of the child threads for some specific asynchronous I/O tasks which execute in the background.	
DdL6]^9eKy	Basic-66869	Interview Quesions::NodeJS	Explain stream in Node.js along with its various types.	Streams in Node.js are the collection of data similar to arrays and strings. They are objects using which you can read data from a source or write data to a destination in a continuous manner. It might not be available at once and need not to have fit in the memory. These streams are especially useful for reading and processing a large set of data. In Node.js, there are four fundamental types of streams:Readable: Used for reading large chunks of data from the source.Writeable: Use for writing large chunks of data to the destination.Duplex: Used for both the functions; read and write.Transform: It is a duplex stream that is used for modifying the data.	
x+qX={hW:	Basic-66869	Interview Quesions::NodeJS	List down the various timing features of Node.js.	https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick Node.js provides a Timers module which contains various functions for executing the code after a specified period of time. Below I have listed down the various functions provided by this module:setTimeout/clearTimeout – Used to schedule code execution after a designated amount of millisecondssetInterval/clearInterval – Used to execute a block of code multiple timessetImmediate/clearImmediate – Used to execute code at the end of the current event loop cycleprocess.nextTick – Used to schedule a callback function that needs to be invoked in the next iteration of the Event Loop	
nh{/j`:{h2	Basic-66869	Interview Quesions::NodeJS	What do you understand by an Event Emitter in Node.js?	EventEmitter is a Node.js class that includes all the objects that are capable of emitting events. These objects contain an eventEmitter.on() function which can attach more than one function to the named events that are emitted by the object. Whenever an EventEmitter object throws an event (use evenEmitter.emit()), all the attached functions to that specific event are invoked synchronously.	
AU>a>ZW8!w	Basic-66869	Interview Quesions::NodeJS	The priority of require('something') module	"•	
ck!%(J[b<<	Basic-66869	Interview Quesions::NodeJS	Scanning for node_modules	"Ex: If a file /home/ryo/project/foo.js has a require call require('bar'), Node.js scans the file system for node_modules in the following order: •	
JTrq&Lbe,S	Basic-66869	Interview Quesions::NodeJS	File-Based Module characteristic	Conditionally Load a Module Blocking: The require function blocks further code execution until the module has been loaded. Cached: after the first time a require call is made to a particular file, the module.exports is cached. The next time a call made, the module.exports variable of the destination file is returned from memory, keeping things fast.	
iUMzXO(8Ml	Basic-66869	Interview Quesions::NodeJS	Types of modules? The require order?	- Core module: require('fs') - File-based module: require('../foo') - Folder-based module: require('../foo'), require('../foo/index'); - File/Folder in node_module: require('foo') - Folder with package.json and main property - Folder with index.js file -> If more than 1 case matched, the priority is based on the above order	
Jop|IV]kWN	Basic-66869	Interview Quesions::NodeJS	main vs exports in package.json	In a package.json file, main, module, browser, types, and exports are fields used to define how a package is consumed in different environments and contexts. main: This field specifies the primary entry point for a CommonJS module. When a package is `require()`d in a Node.js environment, the file specified in main is loaded. It's a legacy field, primarily for CommonJS. module: This field specifies the primary entry point for an ES module (ESM). Bundlers and tools that understand ESM will use this field to resolve imports when a package is consumed as an ES module. This is particularly relevant for client-side applications that use bundlers like Webpack or Rollup. browser: This field allows you to specify a different entry point or even substitute specific files when your package is used in a browser environment. It can be a string pointing to a browser-specific entry file, or an object mapping Node.js-specific files to browser-compatible alternatives or false to exclude them. types (or typings): This field specifies the path to the TypeScript declaration file (.d.ts) for your package. This allows TypeScript projects consuming your package to benefit from type checking and autocompletion. exports: This is a modern and more powerful field that defines the package's entry points and subpath exports for different environments and module formats (CommonJS, ESM, browser, Node.js). It allows for conditional exports, enabling a single package to provide optimized versions for various consumers. The exports field takes precedence over main and module when present. It offers features like:Conditional Exports: Specifying different files for different environments (e.g., node, browser, import, require).Subpath Exports: Exposing specific internal files or directories as public entry points.Encapsulation: Limiting access to internal files not explicitly defined in exports. In essence, main and module define the main entry points for CommonJS and ESM respectively, browser handles browser-specific overrides, types provides TypeScript definitions, and exports offers a comprehensive and flexible way to manage entry points and module resolution across diverse environments and module systems. fallback priority: exports > browser > module > main In summary, the priority is generally: exports: If present, it dictates all entry point and type resolution.types (within exports conditions): Takes precedence for type resolution when exports is used.types (top-level): Used if exports is not present or does not specify types for a given condition.browser: When in a browser environment and exports is not used.module: For ESM consumption when exports is not used and browser doesn't apply.main: The fallback entry point for CommonJS consumption when exports is not used and browser or module don't apply.	
0et0}@IR,]	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between an id and a class in HTML/CSS?	An id is a unique identifier for a single HTML element.\nA class is a reusable identifier that can be applied to multiple elements.\n\nIn CSS, an id is selected using the # symbol, while a class is selected using the . symbol.	
a!hfOCYM!!	Basic-66869	Interview Quesions::HTML/CSS	Can you explain the box model in CSS?	The CSS box model describes the rectangular boxes generated for elements in the DOM. The box model is composed of the following layers:\n\n1. Content: The innermost part, where text and images appear.\n\n2. Padding: The space between the content and the border.\n\n3. Border: The outer edge of the padding, surrounding the element.\n\n4. Margin: The space outside the border, separating the element from others.	
N!|Y0|U?|a	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between inline, inline-block, and block elements?	In CSS, the difference between inline, inline-block, and block elements is on the way they’re rendered in the web page:\n\nInline: Inline elements don’t have a width or height. Instead, they don’t start on a new line and take up only the width that’s required (based on their content). Examples: <span>, <a>.\n\nInline-block: Just like inline elements, here the DOM elements do not start on a new line, however, they do allow you to set a height and width on them. Example: <img>.\n\nBlock: Elements start on a new line, taking up the full width available by default. Their width and height can be set by you. Examples: <div>, <p>.	
M{HCKbf4gg	Basic-66869	Interview Quesions::HTML/CSS	What is the difference between the em and rem units?	They’re both relative units of measurement, however, they’re relative to different things:\n\n“em” units are relative to the font size of their parent element. So if the parent element has a font size of 20px, then setting a “2em” font size, would equal to 40px.\n\n“rem” units are “root em”, which means they’re relative to the web page’s root element (the “<html>” element).	
T.F]!|Pt]=	Basic-66869	Interview Quesions::HTML/CSS	Flexbox vs Grid vs Box Layout	Flexbox is a one-dimensional layout model that arranges items in a row or a column. It’s best used for smaller layout changes, like aligning items in a navigation bar or a footer.\n\nGrid is a two-dimensional layout model that arranges items in rows and columns. It’s best used for larger layout changes, like creating a responsive grid layout for a website.\n\nBox Layout is the default layout model in CSS. It’s based on the box model, where each element is a rectangular box. It’s best used for simple layouts, like centering an element on the page.	
1;F_A1PB2H	Basic-66869	Interview Quesions::HTML/CSS	Can you explain CSS specificity and how it works?		
Sqtsume:j!	Basic-66869	Interview Quesions::HTML/CSS	What are media queries?		
wS1usH;.%,	Basic-66869	Interview Quesions::HTML/CSS	Explain some of the pros and cons for CSS animations versus JavaScript animations.	"Use CSS animations for simpler ""one-shot"" transitions, like toggling UI element states.Use JavaScript animations when you want to have advanced effects like bouncing, stop, pause, rewind, or slow down.If you choose to animate with JavaScript, use the Web Animations API or a modern framework that you're comfortable with."	
I=(rs!mcK2	Basic-66869	Interview Quesions::HTML/CSS	"Css Selector: ~, >, +, #, ."	"div p: Selects all <p> elements inside <div> elements p.intro:Selects all <p> elements with class=""intro""#firstname:Selects the element with id=""firstname"" .name1.name2: Selects all elements with both name1 and name2 set within its class attribute .name1 .name2:Selects all elements with name2 that is a descendant of an element with name1div > p:Selects all <p> elements where the parent is a <div> elementdiv + p:Selects the first <p> element that is placed immediately after <div> elementsp ~ ul: Selects all <ul> elements that is placed after <p> elementCSS Selectors Reference (w3schools.com)"	
d:7nK*Ymy9	Basic-66869	Interview Quesions::HTML/CSS	css vs css-in-js		
zWjYlzDs.H	Basic-66869	Interview Quesions::HTML/CSS	tailwindcss vs css		
BU66(j|7Q6	Basic-66869	Interview Quesions::HTML/CSS	sass vs postcss		
JKE3#s;N,~	Basic-66869	Interview Quesions::Operation System	What do you mean by an operating system?	Operating System (OS) is basically a software program that manages and handles all resources of a computer such as hardware and software. An OS is responsible for managing, handling, and coordinating overall activities and sharing computer resources. It acts as an intermediary among users of computer and computer hardware.	
uv|en.AHg$	Basic-66869	Interview Quesions::Operation System	Scheduling Algorithm	FCFS (First Come First Serve) the process that arrives first will be executed first Its implementation is based on FIFO queue. Poor performance as the average wait time is high. Problem of starvation Shortest-Job-Next (SJN) Scheduling This is also known as shortest job first, or SJF Priority Scheduling Each process is assigned a priority. The process with the highest priority is to be executed first and so on. Processes with the same priority are executed on a first-come first-served basis. Priority can be decided based on memory requirements, time requirements, or any other resource requirement. Shortest Remaining Time The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with a shorter time to completion. It is often used in batch environments where short jobs need to give preference. Round Robin(RR) Scheduling Each process is provided a fixed time to execute, it is called a quantum. Once a process is executed for a given time period, it is preempted and another process executes for a given time period.	
yrzG*5gt,9	Basic-66869	Interview Quesions::Operation System	Difference between Counting and Binary Semaphores		
F[`oHyR0#+	Basic-66869	Interview Quesions::Operation System	What is Deadlock?	Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.	
KlMh0bw.BW	Basic-66869	Interview Quesions::Operation System	Ram vs Cache	The cache is a fast memory component that stores frequently used data by the CPU, whereas RAM is a computing device that stores data and programs currently used by the CPU.	
j$;a%oDmvF	Basic-66869	Interview Quesions::Operation System	Thread vs Process	Process means a program is in execution, whereas thread means a segment of a process.	
Q-XGbT=@Ya	Basic-66869	Interview Quesions::Operation System	Multi-thread vs multi-process	Multiprocessing uses two or more CPUs to increase computing power, whereas multithreading uses a single process with multiple code segments to increase computing power. Multiprocessing increases computing power by adding CPUs, whereas multithreading focuses on generating computing threads from a single process	
z=/6B}uLg9	Basic-66869	Interview Quesions::Operation System	Virtual Memory (VM), VM paging and Page Fault		
El7a?ezq/J	Basic-66869	Interview Quesions::Operation System	Ram vs Rom	RAM and ROM are both computer devices. RAM, which stands for random access memory, is volatile memory that temporarily stores the files you are working on. ROM, which stands for read-only memory, is non-volatile memory that permanently stores instructions for your computer.	
yHS9$RuksI	Basic-66869	Interview Quesions::Operation System	Solution to the Critical Section Problem	The critical section problem needs a solution to synchronize the different processes. The solution to the critical section problem must satisfy the following conditions −Mutual Exclusion Mutual exclusion implies that only one process can be inside the critical section at any time. If any other processes require the critical section, they must wait until it is free.Progress Progress means that if a process is not using the critical section, then it should not stop any other process from accessing it. In other words, any process can enter a critical section if it is free.Bounded Waiting Bounded waiting means that each process must have a limited waiting time. Itt should not wait endlessly to access the critical section.	
eY:H2@%.4	Basic-66869	Interview Quesions::General	Semantic Versioning	"Semantic versioning means versioning your software in a way that the version numbers have significant meaning. Node.js developers follow a three-digit versioning: •	
hN8B`-(Jk+	Basic-66869	Interview Quesions::General	Optimistic UI Design	Basically, It update the UI base on the predictable states immediately without waiting for the data response (The response time should be less than 2s)	
N^VAY=#;8?	Basic-66869	Interview Quesions::General	Atomic design methodology	Atomic design is a methodology composed of five distinct stages working together to create interface design systems in a more deliberate and hierarchical manner. The five stages of atomic design are:Atoms: The UI Elements that serve as the elemental building blocks of an interface.Molecules: are collections of atoms that form relatively simple UI components.Organisms: complex UI components composed of groups of molecules and/or atoms and/or other organismsTemplates: place components into a layout and demonstrate the design’s underlying content structurePages: apply real content to templates to demonstrate the final UI and test	
xl$L(ll3{<	Basic-66869	Interview Quesions::General	What are Micro Frontends? Pros and cons	Micro frontends are a new pattern where web application UIs (front ends) are composed from semi-independent fragments that can be built by different teams using different technologies. Advantages: - Team Scalability - Strategic vs Tatical Focus - Reusability - Multiple frameworks Disavantages: - Complexity (Communication, Develop and deploy) - No Standards - Increased Payloads	
BajKzoY8*c	Basic-66869	Interview Quesions::General	SQL vs noSQL database	SQL is the programming language used to interface with relational databases. NoSQL is a class of DBMs that are non-relational and generally do not use SQL.	
kUN[}Z<I0M	Basic-66869	Interview Quesions::General	Consistency, Availability and Partition Tolerance Trade offs	Tradeoff between consistency, availability and latency exists even when there are no network partitions. Reason for tradeoff is that a high availability requirement implies that the system must replicate data.	
IrHPS@zxIm	Basic-66869	Interview Quesions::General	Monolith Repo?	An app architecture for managing multiple packages from your local files system within a singular top-level, root package. Dependencies can be linked together, which is also a better mechanism than yarn link All your project dependencies will be installed together	
x33bnAGIDa	Basic-66869	Interview Quesions::General	How do you handle state management in single-page applications?	Without a full framework or library like React or Vue.js, properly handling state management is not a trivial task.\n\nSome options available through the language itself are:\n\nGlobal Variables: You can use global variables, or perhaps a global object to centralize state. The problem with this approach is that it can become quite unmanageable for large applications. It’s also a lot harder to maintain local state inside single components.\n\nModule Pattern: You can use this pattern to encapsulate state and provide a clear API to manage it. You would have to instantiate local instances of these modules for individual components.\n\nPub/Sub Pattern: This option is more sophisticated, and it decouples state changes using event-driven architecture. It’s a more complex solution, but it provides a bigger flexibility.\n\nState Management Libraries: You can always use something like Redux or similar libraries without frameworks.	
t@x*lA5n0K	Basic-66869	Interview Quesions::General	Popular State Managements	- Redux: Predictable state container - Zustand: state-management solution using simplified flux principles. The store is a hook which can be used anywhere, no provider needed. - RxJS: a library for reactive programming using Observables - React-query: data-fetching library for React. it makes fetching, caching, synchronizing and updating server state in React applications easier	
lyg>gf8Nk-	Basic-66869	Interview Quesions::General	How to write effective unit test	Test Small Pieces of Code in Isolation Follow Arrange, Act, Assert Keep Tests Short and simple Cover Happy Path First then Test Edge Cases Write Tests Before Fixing Bugs Make Them Performant Keep Them Stateless and consistent Use Descriptive Names	
ifN|rI<[%Q	Basic-66869	Interview Quesions::General	What is Bundler? Webpack vs Rollup vs Parcel		
C0,[2LZ@7Q	Basic-66869	Interview Quesions::General	CommonJS vs RequireJS (AMD) vs ES6 module	- — — — — CommonJS vs AMD vs RequireJS vs ES6 Modules — — — — - | by Mohanesh Sridharan | Computed Comparisons | Medium - CommonJS: sync module loading, browsers cannot use directly without transpiling - AMD: async module loading, can be used in browser - ES6: native JS, both sync and async module loading, need a transpiler like Babel for old browsers	
o?*gFk]U-l	Basic-66869	Interview Quesions::General	Webpack properties: entry, output, resolve, module, plugins	npx webpack takes entry script as entry point and generate output as output value - resolve: Configure how modules are resolved. + alias: Instead of using relative paths when importing, you can use the alias + extensions: Attempt to resolve these extensions in order. This will override the default array -> you can use '...' to access the default extensions - modules: determine how the different types of modules within a project will be treated. + rules: modify how the module is created. They can apply loaders to the module, or modify the parser. - plugins: array of webpack plugins which allowing different behavior between development builds and release builds.	
Ir#)rPdX<J	Basic-66869	Interview Quesions::General	Babel webpack plugins: @babel/core, @babel/plugin-transform-runtime, @babel/preset-env, @babel/preset-react		
z|37yN*TyO	Basic-66869	Interview Quesions::General	TypeScript configurations		
oWn$-@C,-u	Basic-66869	Interview Quesions::General	Monorepo vs MultiRepo	Should my component library be a monorepo? | Mae Capozzi's Blog	
|0!0CpBzT_	Basic-66869	Interview Quesions::General	What is tree shaking, and how does it help with the performance of a web application?	Tree shaking is a technique used in JavaScript module bundlers, like Webpack or Vite, to remove unused code from the final bundled output.\n\nMain benefits include:\n\nReduced Bundle Size: Removing unused code reduces the size of the JavaScript bundle sent to the client, improving load times and reducing bandwidth usage.\n\nImproved Performance: Smaller bundle sizes can lead to faster parsing and execution times, resulting in improved performance and responsiveness of the web application.\n\nBetter Resource Utilization: Developers can write modular code without worrying about unused dependencies bloating the final bundle size.	
pI8_%h25(#	Basic-66869	Interview Quesions::General	Functional Programming	Functional programming is the process of building software by composing pure functions, avoiding shared state, mutable data, and side-effects. Functional programming is declarative rather than imperative, and application state flows through pure functions Fundamentals of functional programming with React - LogRocket Blog	
L<`X3^^)Qq	Basic-66869	Interview Quesions::General	OOP (Object-oriented programming)		
nHvEZ*!+FP	Basic-66869	Interview Quesions::General	Refactoring/Code Review	moving code to where it most logically belongsremoving duplicate codemaking names self-documentingsplitting methods into smaller piecesre-arranging inheritance hierarchies Refactoring: clean your code	
HTyE=OQv5s	Basic-66869	Interview Quesions::General	Code Review checklist	Should - Try to Identify Obvious Bugs - Look for Possible Security Issues - Look for “Clever” Code - Check for Code Duplication - Check for Code following a standardized process of the team - Check Whether Names Are Descriptive Enough - Look for Possible Performance Improvements an expensive operation inside a loopexcessive allocations of objectsinefficient string concatenationsinefficient logging - Check the Presence and Quality of Tests The presence of tests: Did the author create tests for their change?The quality of tests: Do the tests created seem to effectively exercise the system under test? Do they follow agreed-upon best practices?Readability: Remember tests are also documentation. They should be simple and easy to understand.Naming: Are the tests named according to the team’s convention? Is it easy to understand what they’re about? - Explain Your Changes - Optional: Code Documentation Should not - Cosmetic Concerns - Manual Testing - Mismatch standardized process of the team between different members What You Need in a Code Review Checklist (& What You Don't) - LinearB	
dL.QS0ur6j	Basic-66869	Interview Quesions::General	Test Driven Development (TDD) Cycle	1. Add a test 2. Run all tests. The new test should fail for expected reasons 3. Write the simplest code that passes the new test 4. All tests should now pass 5. Refactor as needed, using tests after each refactor to ensure that functionality is preserved 6. Repeat from step 1 Development Cycle - Writing the tests first - Each test case fails initially	
IL>ndQ?-Zf	Basic-66869	Interview Quesions::General	What is API gateway?	An API gateway is an API management tool that sits between a client and a collection of backend services. An API gateway acts as a reverse proxy to accept all application programming interface (API) calls, aggregate the various services required to fulfill them, and return the appropriate result. When a client makes a request, the API gateway breaks it into multiple requests, routes them to the right places, produces a response, and keeps track of everything. What does an API gateway do? (redhat.com)	
O)gkj,qXu:	Basic-66869	Interview Quesions::Design Patterns	Singleton Pattern	Share a single global instance throughout our application In React, we often rely on a global state through state management tools such as Redux or React Context instead of using Singletons. Although their global state behavior might seem similar to that of a Singleton, these tools provide a read-only state rather than the mutable state of the Singleton.	
u_nwd~iW?V	Basic-66869	Interview Quesions::Design Patterns	Proxy Pattern	Intercept and control interactions to target objects Proxy can help with validation, formatting, notifications, or debugging. The two most common methods of Proxy handler are get and set	
pP3h4;;xo<	Basic-66869	Interview Quesions::Design Patterns	Provider Pattern/Context API	makes it possible to pass data to many components, without having to manually pass it through each component layer.	
(Pgm]fGAa	Basic-66869	Interview Quesions::Design Patterns	Export and Import in ES6	What is export default in JavaScript ? - GeeksforGeeks ES6 | Import and Export - GeeksforGeeks There are two different types of export, named and default. You can have multiple named exports per module but only one default export. Named exports are useful to export several values. During the import, it is mandatory to import them within curly braces with the same name of the corresponding object. But a default export can be imported with any nameRe-Export/Aggregating // Export From export * from …; // does not set the default export export * as name1 from …; // ECMAScript® 2O20 export { name1, name2, …, nameN } from …; export { import1 as name1, import2 as name2, …, nameN } from …; export { default, … } from …;	
m*1(H_^I<$	Basic-66869	Interview Quesions::Design Patterns	Hook vs HOC	Best use-cases for a HOC:The same, uncustomized behavior needs to be used by many components throughout the application.The component can work standalone, without the added custom logic. Best use-cases for Hooks:The behavior has to be customized for each component that uses it.The behavior is not spread throughout the application, only one or a few components use the behavior.The behavior adds many properties to the component HOC Pattern (patterns.dev)	
wU[uW_$?r~	Basic-66869	Interview Quesions::TypeScript	Generic Type	Generic type allows us to create a specific type by allowing us to pass types into it as parameters, which are reusable in many different situations Array<ItemType> Promise<ReturnedType> ReadOnly Partial Record<KeyType,ValueType>: key-value	
O.YxF`&i?.	Basic-66869	Interview Quesions::TypeScript	What are the primitive types in TypeScript?	string, number, boolean	
kn8xBaO07(	Basic-66869	Interview Quesions::TypeScript	What is any type, and when to use it?	TypeScript assumes a variable is of type any when you don’t explicitly provide the type, and the compiler cannot infer the type of that variable	
K&oN:86Sv&	Basic-66869	Interview Quesions::TypeScript	What is void, and when to use the void type?	The void indicates the absence of type on a variable. It is especially useful in functions that don’t return a value.	
hht^kbbi|a	Basic-66869	Interview Quesions::TypeScript	What is an unknown type, and when to use it in TypeScript?	The unknown type is the type-safe counterpart of any type. You can assign anything to the unknown, but the unknown isn’t assignable to anything but itself and any, without narrowing it to a more specific type.	
d,FQ@[~uaq	Basic-66869	Interview Quesions::TypeScript	Note to Create Strongly typed Component Events and Event Handlers	- the inline event handler is strongly-typed because TypeScript has cleverly inferred the type - named function event handler is not strongly-typed => explicitly typed by type annotation (tips: hover over the event handler to discover the type annotation)	
q+B]J_`xvE	Basic-66869	Interview Quesions::TypeScript	"<input type=""text"" onKeyDown={e:React.KeyboardEvent<HTMLInputElement> => console.log(e.key)} /> What is wrong?"	We must wrap event paramaters by round bracket while we are using type annotation	
dsd,r&{3eh	Basic-66869	Interview Quesions::TypeScript	declare type for actions and dispatchs of redux-thunk		
BLXGnxR].3	Basic-66869	Interview Quesions::TypeScript	declare enum type		
mtG$I:ww}V	Basic-66869	Interview Quesions::Network & Security	Injection	- What? Untrusted user input is interpreted by server and executed - Impact: Data can be stolen, modified and deleted - Prevent: + Reject untrusted/invalid input data + Use latest framework + Penetration test + Security code review	